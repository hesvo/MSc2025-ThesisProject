id,language,reference,generated,generated_rci,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype == ""int"":
        return isinstance(value, int)
    elif datatype == ""float"":
        return isinstance(value, float)
    elif datatype == ""str"":
        return isinstance(value, str)
    elif datatype == ""bool"":
        return isinstance(value, bool)
    elif datatype == ""list"":
        return isinstance(value, list)
    elif datatype == ""tuple"":
        return isinstance(value, tuple)
    elif datatype == ""dict"":
        return isinstance(value, dict)
    elif datatype == ""set"":
        return isinstance(value, set)
    else:
        return False","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype == ""int"":
        return isinstance(value, int)
    elif datatype == ""float"":
        return isinstance(value, float)
    elif datatype == ""str"":
        return isinstance(value, str)
    elif datatype == ""bool"":
        return isinstance(value, bool)
    elif datatype == ""list"":
        return isinstance(value, list)
    elif datatype == ""tuple"":
        return isinstance(value, tuple)
    elif datatype == ""dict"":
        return isinstance(value, dict)
    elif datatype == ""set"":
        return isinstance(value, set)
    else:
        return False",37.1611529750151,9.74150876536819,35.826180057769115,23.076923076923077,80.0
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        for v in value:
            if not is_xintx(v, signed, bits):
                return False
        return True
    elif isinstance(value, int):
        if signed:
            if value < -(2**(bits-1)) or value > 2**(bits-1)-1:
                return False
        else:
            if value < 0 or value > 2**bits-1:
                return False
        return True
    else:
        return False","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        for v in value:
            if not is_xintx(v, signed, bits):
                return False
        return True
    elif isinstance(value, int):
        if signed:
            if value < -(2**(bits-1)) or value > 2**(bits-1)-1:
                return False
        else:
            if value < 0 or value > 2**bits-1:
                return False
        return True
    else:
        return False",30.26505092292469,16.671973698980285,18.931344535833023,47.61904761904761,37.83783783783784
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_name, type_func, type_args in cls._type_definitions:
        if type_name == datatype:
            return type_name, type_func, type_args
    return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_name, type_func, type_args in cls._type_definitions:
        if type_name == datatype:
            return type_name, type_func, type_args
    return None",60.865774346132895,44.012943788324186,54.669008815062604,62.96296296296296,81.81818181818183
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","```python
def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        fqn = get_fqn()
    fqn_parts = fqn.split(""."")
    fqn_parts.pop()
    fqn_parts.reverse()
    fqn_parts.pop()
    fqn_parts.reverse()
    fqn_parts_str = ""."".join(fqn_parts)
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts","```python
def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        fqn = get_fqn()
    fqn_parts = fqn.split(""."")
    fqn_parts.pop()
    fqn_parts.reverse()
    fqn_parts.pop()
    fqn_parts.reverse()
    fqn_parts_str = ""."".join(fqn_parts)
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts_str.replace(""::"", ""."")
    fqn_parts_str = fqn_parts",27.202154881158556,6.2452430777240115,25.885135706169482,35.9375,40.74074074074074
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","import typing
from dataclasses import dataclass
from enum import Enum

class ApiGearType(Enum):
    STRING = ""string""
    INTEGER = ""integer""
    BOOLEAN = ""boolean""
    FLOAT = ""float""
    ARRAY = ""array""
    OBJECT = ""object""
    ANY = ""any""

@dataclass
class ApiGearType:
    type: str
    description: str = """"
    items: typing.Optional[ApiGearType] = None
    properties: typing.Optional[typing.Dict[str, ApiGearType]] = None
    additional_properties: bool = False

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType(type=""string"")
    elif t == ""integer"":
        return ApiGearType(type=""integer"")
    elif t == ""boolean"":
        return ApiGearType(type=""boolean"")
    elif t == ""float"":
        return ApiGearType(type=""float"")
    elif t == ""array"":
        return ApiGearType(type=""array"")
    elif t == ""object"":
        return ApiGearType(type=""object"")
    elif t == ""any"":
        return ApiGearType(type=""any"")
    else:
        return None","import typing
from dataclasses import dataclass
from enum import Enum

class ApiGearType(Enum):
    STRING = ""string""
    INTEGER = ""integer""
    BOOLEAN = ""boolean""
    FLOAT = ""float""
    ARRAY = ""array""
    OBJECT = ""object""
    ANY = ""any""

@dataclass
class ApiGearType:
    type: str
    description: str = """"
    items: typing.Optional[ApiGearType] = None
    properties: typing.Optional[typing.Dict[str, ApiGearType]] = None
    additional_properties: bool = False

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType(type=""string"")
    elif t == ""integer"":
        return ApiGearType(type=""integer"")
    elif t == ""boolean"":
        return ApiGearType(type=""boolean"")
    elif t == ""float"":
        return ApiGearType(type=""float"")
    elif t == ""array"":
        return ApiGearType(type=""array"")
    elif t == ""object"":
        return ApiGearType(type=""object"")
    elif t == ""any"":
        return ApiGearType(type=""any"")
    else:
        return None",20.910125634057792,12.75861073132178,16.20323229526192,30.08849557522124,24.59016393442623
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","```python
def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if node.type == ""STRUCT_FIELD"":
        return None
    elif node.type == ""STRUCT_MEMBER"":
        return None
    elif node.type == ""ENUM_MEMBER"":
        return None
    elif node.type == ""FIELD"":
        return ApiGearProperty(
            name=node.name,
            datatype=datatype,
            bit_length=node.bit_length,
            is_array=node.is_array,
            is_optional=node.is_optional,
            is_union=node.is_union,
            is_constant=node.is_constant,
            is_volatile=node.is_volatile,
            is_signed=node.is_signed,
            is_little_endian=node.is_little_endian,
            is_big_endian=node.is_big_endian,
            is_signed_integer=node.is_signed_integer,
            is_unsigned_integer=node.is_unsigned_integer,
            is_float=node.is_float,
            is_double=node.is_double,
            is_boolean=node.is_boolean,
            is_string=node.is_string,
            is_byte=node.is_byte,
            is_char=node.is_char,
            is_short=node.is_short,
            is_long=node.is_long,
            is_longlong=node.is_longlong,
            is_uint8=node.is_uint8,
            is_uint16=node.is_uint16,
            is_uint32=node.is_uint32,
            is_uint64=node.is_uint64,
            is_int8=node.is_int8,
            is_int16=node.is_int16,
            is_int32=node.is_int32,
            is_int64=node.is_int64,
            is_uint=node.is_uint,
            is_int=node.is_int,
            is_struct=node.is_struct,
            is_union=node.is_union,
            is_enum=node.is_enum,
            is_bitfield=node.is_bitfield,
            is_function=node.is_function,
            is_constant=node.is_constant,
            is_volatile=node.is_volatile,
            is_static=node.is_static,
            is_extern=node.is_extern,
            is_inline=node.is_inline,
            is_const=node.is_const,
            is_mutable=node.is_mutable,
            is_register=node.is_register,
            is_thread_local=node.is_thread_local,
            is_deprecated=node.is_deprecated,
            is_override=node.is_override,
            is_final=node.is_final,
            is_virtual=node.is_virtual,
            is_pure_virtual=node.is_pure_virtual,
            is_protected=node.is_protected,
            is_private=node.is_private,
            is_friend=node.is_friend,
            is_friend_class=node.is_friend_","```python
def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if node.type == ""STRUCT_FIELD"":
        return None
    elif node.type == ""STRUCT_MEMBER"":
        return None
    elif node.type == ""ENUM_MEMBER"":
        return None
    elif node.type == ""FIELD"":
        return ApiGearProperty(
            name=node.name,
            datatype=datatype,
            bit_length=node.bit_length,
            is_array=node.is_array,
            is_optional=node.is_optional,
            is_union=node.is_union,
            is_constant=node.is_constant,
            is_volatile=node.is_volatile,
            is_signed=node.is_signed,
            is_little_endian=node.is_little_endian,
            is_big_endian=node.is_big_endian,
            is_signed_integer=node.is_signed_integer,
            is_unsigned_integer=node.is_unsigned_integer,
            is_float=node.is_float,
            is_double=node.is_double,
            is_boolean=node.is_boolean,
            is_string=node.is_string,
            is_byte=node.is_byte,
            is_char=node.is_char,
            is_short=node.is_short,
            is_long=node.is_long,
            is_longlong=node.is_longlong,
            is_uint8=node.is_uint8,
            is_uint16=node.is_uint16,
            is_uint32=node.is_uint32,
            is_uint64=node.is_uint64,
            is_int8=node.is_int8,
            is_int16=node.is_int16,
            is_int32=node.is_int32,
            is_int64=node.is_int64,
            is_uint=node.is_uint,
            is_int=node.is_int,
            is_struct=node.is_struct,
            is_union=node.is_union,
            is_enum=node.is_enum,
            is_bitfield=node.is_bitfield,
            is_function=node.is_function,
            is_constant=node.is_constant,
            is_volatile=node.is_volatile,
            is_static=node.is_static,
            is_extern=node.is_extern,
            is_inline=node.is_inline,
            is_const=node.is_const,
            is_mutable=node.is_mutable,
            is_register=node.is_register,
            is_thread_local=node.is_thread_local,
            is_deprecated=node.is_deprecated,
            is_override=node.is_override,
            is_final=node.is_final,
            is_virtual=node.is_virtual,
            is_pure_virtual=node.is_pure_virtual,
            is_protected=node.is_protected,
            is_private=node.is_private,
            is_friend=node.is_friend,
            is_friend_class=node.is_friend_",32.76842675487549,9.569432697778309,23.17094098839031,33.33333333333333,65.0
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser


def load_vspec(include_dirs: List[Path], specs: List[Path], identifier: Optional[str] = None) -> VSpec:
    """"""Loads and merges multiple VSpec files from specified paths into a single VSpec object""""""
    vspec = VSpec()
    for spec in specs:
        vspec.add_spec(VSpecParser.parse_file(spec, include_dirs, identifier))
    return vspec","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser


def load_vspec(include_dirs: List[Path], specs: List[Path], identifier: Optional[str] = None) -> VSpec:
    """"""Loads and merges multiple VSpec files from specified paths into a single VSpec object""""""
    vspec = VSpec()
    for spec in specs:
        vspec.add_spec(VSpecParser.parse_file(spec, include_dirs, identifier))
    return vspec",17.222384683960186,4.592793400981667,4.968579960182062,24.444444444444443,34.883720930232556
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict):
            base[k] = deep_update(base.get(k, {}), v)
        else:
            base[k] = v","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict):
            if k not in base:
                base[k] = v
            else:
                base[k] = deep_update(base[k], v)
        else:
            base[k] = v",49.22226270225758,32.01690490237838,32.58047923998528,66.66666666666666,65.625
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if not isinstance(v, str):
        return None
    if len(v) != 8:
        return None
    try:
        int(v, 16)
    except ValueError:
        return None
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if not isinstance(v, str):
        return None
    if len(v) != 8:
        return None
    try:
        int(v, 16)
    except ValueError:
        return None
    return v",50.55735832975432,40.37469867061998,51.8547346483973,40.0,70.0
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if not vss_raw.resolve(fqn):
        return vss_raw
    return None

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6,","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if not vss_raw.resolve(fqn):
        return vss_raw
    return None

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> subarray;
    for (int i = 0; i < n - k + 1; i++) {
        subarray.clear();
        for (int j = i; j < i + k; j++) {
            subarray.push_back(arr[j]);
        }
        sort(subarray.begin(), subarray.end());
        cout << ""Subarray: "";
        for (int j = 0; j < subarray.size(); j++) {
            cout << subarray[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8,",39.187464613481836,2.8507641709187777,33.06576094967523,47.5,73.33333333333333
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [str(cls), ""int"", ""float"", ""bool""]
    result = []
    for value in values:
        if value in valid_datatypes:
            result.append(value)
        else:
            result.append(None)
    return result","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [str(cls), ""int"", ""float"", ""bool""]
    result = []
    for value in values:
        if value in valid_datatypes:
            result.append(value)
        else:
            result.append(None)
    return result",43.4876828546502,28.008294138571454,37.60910394669599,50.0,58.333333333333336
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        node_str = """"
        for attr in attributes:
            node_str += f""{attr}: {getattr(node, attr)}\n""
        node_str += ""├── ""
        if node.children:
            node_str += ""\n""
            for child in node.children:
                node_str += ""│   "" + render_node(child, indent + 4)
        else:
            node_str += ""└──\n""
        return node_str

    return render_node(tree, 0)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        node_str = """"
        for attr in attributes:
            node_str += f""{attr}: {getattr(node, attr)}\n""
        node_str += ""├── ""
        if node.children:
            node_str += ""\n""
            for child in node.children:
                node_str += ""│   "" + render_node(child, indent + 4)
        else:
            node_str += ""└──\n""
        return node_str

    return render_node(tree, 0)",24.330569927953565,12.398158141577813,15.774323999386256,32.30769230769231,36.84210526315789
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if self.parent is None:
        return self, depth
    else:
        return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if self.parent is None:
        return self, depth
    else:
        return self.parent.get_instance_root(depth + 1)",50.9090059046418,45.05992343458631,45.68136334187565,55.00000000000001,57.89473684210527
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    count = 0
    while self.parent is not None:
        count += 1
        self = self.parent
    return count","def count_instance_children_depth(self) -> int:
    count = 0
    current = self
    while current.parent is not None:
        count += 1
        current = current.parent
    return count",24.198239791888565,13.78592993183041,14.062929856841858,26.08695652173913,42.857142857142854
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.startswith(name + '_'):
            children_ids.append(node_id)
    return children_ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.startswith(name + '_'):
            children_ids.append(node_id)
    return children_ids",64.22545578221317,40.64458257395656,42.92390722156277,73.33333333333333,100.0
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        return getattr(o, name)
    except AttributeError:
        return default","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        return getattr(o, name)
    except AttributeError:
        return default",42.338134767853695,36.67473999422677,37.67779907718803,41.66666666666667,53.333333333333336
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""signal"":
        fd.write(f""message {tree.name} {{\n"")
        for field in tree.fields:
            fd.write(f""  {field.type} {field.name} = {field.number};\n"")
        fd.write(""}\n\n"")
    elif tree.type == ""group"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""enum"":
        fd.write(f""enum {tree.name} {{\n"")
        for child in tree.children:
            fd.write(f""  {child.name} = {child.number};\n"")
        fd.write(""}\n\n"")
    elif tree.type == ""service"":
        fd.write(f""service {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""message"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""field"":
        fd.write(f""  {tree.type} {tree.name} = {tree.number};\n"")
    elif tree.type == ""option"":
        fd.write(f""option {tree.name} = {tree.value};\n"")
    elif tree.type == ""package"":
        fd.write(f""package {tree.name};\n\n"")
    elif tree.type == ""import"":
        fd.write(f""import \""{tree.name}\"";\n\n"")
    elif tree.type == ""include"":
        fd.write(f""include \""{tree.name}\"";\n\n"")
    elif tree.type == ""extend"":
        fd.write(f""extend {tree.name};\n\n"")
    elif tree.type == ""oneof"":
        fd.write(f""oneof {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""map"":
        fd.write(f""map<"")
        if tree.key_type:
            fd.write(f""{tree.key_type}"")
        else:
            fd.write(""int32"")
        fd.write(f"", {tree.value_type}"")
        if add_optional:
            fd.write("" = optional("")
            fd.write(f""{tree.value_type}"")
            fd.write("")"")
        fd.write(f"" {tree.name} = {tree.number};\n"")
    elif tree.type == ""repeated"":
        fd.write(f""repeated {tree.value_type} {tree.name} =","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""signal"":
        fd.write(f""message {tree.name} {{\n"")
        for field in tree.fields:
            fd.write(f""  {field.type} {field.name} = {field.number};\n"")
        fd.write(""}\n\n"")
    elif tree.type == ""group"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""enum"":
        fd.write(f""enum {tree.name} {{\n"")
        for child in tree.children:
            fd.write(f""  {child.name} = {child.number};\n"")
        fd.write(""}\n\n"")
    elif tree.type == ""service"":
        fd.write(f""service {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""message"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""field"":
        fd.write(f""  {tree.type} {tree.name} = {tree.number};\n"")
    elif tree.type == ""option"":
        fd.write(f""option {tree.name} = {tree.value};\n"")
    elif tree.type == ""package"":
        fd.write(f""package {tree.name};\n\n"")
    elif tree.type == ""import"":
        fd.write(f""import \""{tree.name}\"";\n\n"")
    elif tree.type == ""include"":
        fd.write(f""include \""{tree.name}\"";\n\n"")
    elif tree.type == ""extend"":
        fd.write(f""extend {tree.name};\n\n"")
    elif tree.type == ""oneof"":
        fd.write(f""oneof {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(""}\n\n"")
    elif tree.type == ""map"":
        fd.write(f""map<"")
        if tree.key_type:
            fd.write(f""{tree.key_type}"")
        else:
            fd.write(""int32"")
        fd.write(f"", {tree.value_type}"")
        if add_optional:
            fd.write("" = optional("")
            fd.write(f""{tree.value_type}"")
            fd.write("")"")
        fd.write(f"" {tree.name} = {tree.number};\n"")
    elif tree.type == ""repeated"":
        fd.write(f""repeated {tree.value_type} {tree.name} = {tree",28.220691649210032,6.398031548033703,19.16132916869952,39.175257731958766,48.148148148148145
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for node in root.children:
        if isinstance(node, VSSBranch):
            instances[node.fqn] = [child.fqn for child in node.children if isinstance(child, VSSLeaf)]
    return instances","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for node in root.children:
        if isinstance(node, VSSBranch):
            instances[node.fqn] = [child.fqn for child in node.children if isinstance(child, VSSLeaf)]
    return instances",24.74135750309787,14.078262538361416,19.792163955381213,34.48275862068966,30.612244897959183
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, (int, float, str, bool))","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, (int, float, str, bool))",50.56589049673828,34.846944887433075,31.7023313852343,35.714285714285715,100.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return node.is_branch and not node.is_instance","def is_VSS_branch(node: VSSNode) -> bool:
    return node.is_branch and not node.is_instance",35.82802108584732,25.916266987614407,25.816869987353826,31.57894736842105,60.0
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.is_branch_instance()","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.is_branch_instance()",30.783772350574136,23.671529472186087,26.130226596777128,33.33333333333333,40.0
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811c9dc5
    hash = offset_basis
    for byte in identifier:
        hash ^= byte
        hash *= FNV_PRIME
        hash &= 0xffffffff
    return hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811c9dc5
    hash = offset_basis
    for byte in identifier:
        hash ^= byte
        hash *= FNV_PRIME
        hash &= 0xffffffff
    return hash",32.75125213237577,23.299898819244838,30.33668865762665,47.368421052631575,30.0
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_card, container, false);
    return view;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_card, container, false);
    return view;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    cout << ""Maximum sum such that no two elements are adjacent: "" << ((incl > excl) ? incl : excl) << endl;

    // Check for Majority Element in a sorted array
    int x = 5;
    bool isMajority = false;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }
    cout << ""Is "" << x << "" a majority element? "" << (isMajority ? ""Yes"" : ""No"") << endl;

    // Find a pair with the given difference
    int diff = 3;
    bool foundPair = false;
    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    cout << ""Maximum sum such that no two elements are adjacent: "" << ((incl > excl) ? incl : excl) << endl;

    // Check for Majority Element in a",43.321025003235924,39.24500924677672,41.278148005224196,51.85185185185185,40.909090909090914
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImage(buttonContent.getImage());
        buttonView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                buttonContent.onClick();
            }
        });
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum += arr[i];
        } else {
            if (arr[i] > arr[i - 1]) {
                current_sum += arr[i];
            } else {
                max_sum = max(max_sum, current_sum);
                current_sum = arr[i];
            }
        }
    }
    max_sum = max(max_sum, current_sum);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImage(buttonContent.getImage());
        buttonView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                buttonContent.onClick();
            }
        });
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i",67.73384863938179,4.7789030573197,82.28552375827198,83.87096774193549,100.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
    if (descriptiveTextOnlyLayoutView == null) {
        descriptiveTextOnlyLayoutView = new DescriptiveTextOnlyLayoutView(this);
    }
    return descriptiveTextOnlyLayoutView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Check for majority element in a sorted array
    int x = 5;
    bool isMajority = false;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    // Find a pair with the given difference
    int diff = 3;
    bool foundPair = false;
    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int","protected final View getDescriptiveTextOnlyLayoutView() {
    if (descriptiveTextOnlyLayoutView == null) {
        descriptiveTextOnlyLayoutView = new DescriptiveTextOnlyLayoutView(this);
    }
    return descriptiveTextOnlyLayoutView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Check for majority element in a sorted array
    int x = 5;
    bool isMajority = false;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    // Find a pair with the given difference
    int diff = 3;
    bool foundPair = false;
    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int",18.39129422292806,1.77304161755952,20.58892671800299,15.909090909090908,35.294117647058826
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    header.setTitle(header.getTitle());
    header.setIcon(header.getIcon());
}","public void updateHeaderView(CardHeader header) {
    header.setTitle(header.getTitle());
    header.setIcon(header.getIcon());
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum = arr[i];
        } else {
            if (arr[i] > current_sum) {
                current_sum = arr[i];
            } else {
                current_sum += arr[i];
            }
        }
        max_sum = max(max_sum, current_sum);
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int max_sum = (incl > excl) ? incl :",53.03570521411256,28.96204682801084,33.18077402843942,50.0,100.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(R.layout.text_block_layout, this, false);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(R.layout.text_block_layout, this, false);
    }
    return mTextBlockLayoutView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum is "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum is "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum is "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl",38.48220934650066,40.19299109447915,44.41766447334169,37.5,31.818181818181817
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setClassName(packageName, ""com.google.android.media.MediaBrowserService"");
    return intent.resolveActivity(packageManager);
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setClassName(packageName, ""com.google.android.media.MediaBrowserService"");
    return intent.resolveActivity(packageManager);
}",21.987655454345298,13.009929608039753,21.63880541688861,28.30188679245283,25.0
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (componentName == null) {
        return false;
    }

    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }

    if (customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }

    if ((appTypesToShow & componentAppType) == 0) {
        return false;
    }

    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    max_sum = ((incl > excl) ? incl : excl);

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }
    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 5;

    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (componentName == null) {
        return false;
    }

    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }

    if (customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }

    if ((appTypesToShow & componentAppType) == 0) {
        return false;
    }

    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    max_sum = ((incl > excl) ? incl : excl);

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }
    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 5;

    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }",57.17089164906248,9.121640533564229,54.48256098332065,69.84126984126983,95.23809523809523
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    carMediaManager.setMediaSource(componentName);
    ((Activity) context).finish();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Check for majority element in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    // Find a pair with the given difference
    int diff = 3;
    int size = arr.size();
    int i = 0, j = 1;

    bool pairFound = false;
    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            pairFound = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!pairFound) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    carMediaManager.setMediaSource(componentName);
    ((Activity) context).finish();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Check for majority element in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    // Find a pair with the given difference
    int diff = 3;
    int size = arr.size();
    int i = 0, j = 1;

    bool pairFound = false;
    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            pairFound = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!pairFound) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl",40.848706541579396,2.9553294390735987,34.95562575950203,35.483870967741936,90.0
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
    try {
        return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
    } catch (Exception e) {
        return false;
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == 5 && arr[i + n / 2] == 5) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }

    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 5) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < 5) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
    try {
        return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
    } catch (Exception e) {
        return false;
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == 5 && arr[i + n / 2] == 5) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }

    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 5) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < 5) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;
    
    for (",35.85941930272144,2.458377745049669,20.78225513086074,34.48275862068966,85.71428571428571
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
    Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
        intent.setPackage(""com.google.android.apps.maps"");
    }
    return intent;
}","private Intent getMapsIntent() {
    Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
        intent.setPackage(""com.google.android.apps.maps"");
    }
    return intent;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;",10.123464586838365,1.9726117047654212,6.703064824406223,15.151515151515152,16.666666666666664
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
    for (String cardName : cardNames) {
        try {
            Class<?> cardClass = Class.forName(cardName);
            Object cardInstance = cardClass.getDeclaredConstructor().newInstance();
            cards.add((HomeCard) cardInstance);
        } catch (ClassNotFoundException e) {
            System.err.println(""Card class not found: "" + cardName);
        } catch (InstantiationException e) {
            System.err.println(""Failed to instantiate card: "" + cardName);
        } catch (IllegalAccessException e) {
            System.err.println(""Failed to access card constructor: "" + cardName);
        } catch (InvocationTargetException e) {
            System.err.println(""Failed to invoke card constructor: "" + cardName);
        } catch (NoSuchMethodException e) {
            System.err.println(""No default constructor found for card: "" + cardName);
        }
    }
}

package org.eclipse.edc.connector.store.sql.schema.postgres;

import org.eclipse.edc.connector.store.sql.schema.BasePostgresSchema;
import org.eclipse.edc.spi.EdcException;
import org.eclipse.edc.spi.query.QuerySpec;
import org.eclipse.edc.spi.result.Result;
import org.eclipse.edc.spi.result.StoreFailure;
import org.eclipse.edc.spi.result.StoreResult;
import org.eclipse.edc.spi.types.domain.DataAddress;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequest;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequestMessage;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequestMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponse;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessage;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowType;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlows;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsRequest;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsResponse;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsRequestMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsResponseMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcess;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessMessages;
import org","private void initializeCards() {
    for (String cardName : cardNames) {
        try {
            Class<?> cardClass = Class.forName(cardName);
            Object cardInstance = cardClass.getDeclaredConstructor().newInstance();
            cards.add((HomeCard) cardInstance);
        } catch (ClassNotFoundException e) {
            System.err.println(""Card class not found: "" + cardName);
        } catch (InstantiationException e) {
            System.err.println(""Failed to instantiate card: "" + cardName);
        } catch (IllegalAccessException e) {
            System.err.println(""Failed to access card constructor: "" + cardName);
        } catch (InvocationTargetException e) {
            System.err.println(""Failed to invoke card constructor: "" + cardName);
        } catch (NoSuchMethodException e) {
            System.err.println(""No default constructor found for card: "" + cardName);
        }
    }
}

package org.eclipse.edc.connector.store.sql.schema.postgres;

import org.eclipse.edc.connector.store.sql.schema.BasePostgresSchema;
import org.eclipse.edc.spi.EdcException;
import org.eclipse.edc.spi.query.QuerySpec;
import org.eclipse.edc.spi.result.Result;
import org.eclipse.edc.spi.result.StoreFailure;
import org.eclipse.edc.spi.result.StoreResult;
import org.eclipse.edc.spi.types.domain.DataAddress;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequest;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequestMessage;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowRequestMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponse;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessage;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowType;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlows;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsRequest;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsResponse;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsRequestMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsResponseMessages;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcess;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessStates;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessTypes;
import org.eclipse.edc.spi.types.domain.transfer.DataFlowsTransferProcessMessages;
import org.eclipse",26.291555486054513,4.968101848922769,7.428889326064506,30.76923076923077,62.0
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        if (taskAppearedInfos == null || taskAppearedInfos.isEmpty()) {
            return;
        }

        for (int i = 0; i < taskAppearedInfos.size(); i++) {
            TaskAppearedInfo taskAppearedInfo = taskAppearedInfos.get(i);
            if (taskAppearedInfo.isMultiWindow()) {
                taskAppearedInfos.remove(i);
                i--;
            }
        }
    }

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == 5 && arr[i + n / 2] == 5) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }

    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 5) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < 5) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr =","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        if (taskAppearedInfos == null || taskAppearedInfos.isEmpty()) {
            return;
        }

        for (int i = 0; i < taskAppearedInfos.size(); i++) {
            TaskAppearedInfo taskAppearedInfo = taskAppearedInfos.get(i);
            if (taskAppearedInfo.isMultiWindow()) {
                taskAppearedInfos.remove(i);
                i--;
            }
        }
    }

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == 5 && arr[i + n / 2] == 5) {
            cout << ""Majority element found"" << endl;
            return 0;
        }
    }

    cout << ""Majority element not found"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 5) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < 5) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2,",29.97592041909845,2.1181486681646167,19.805735028431208,38.88888888888889,59.09090909090909
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
    String mode = intent.getStringExtra(""mode"");
    if (mode != null) {
        mode = mode.substring(0, 1).toUpperCase() + mode.substring(1);
        modeText.setText(mode);
        setTitle(getString(R.string.title_mode) + "" "" + mode);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum such that no two elements are adjacent: "" << maxSum << endl;

    // Check for Majority Element in a sorted array
    int x = 5;
    bool isMajority = false;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    // Find a pair with the given difference
    int diff = 3;
    bool foundPair = false;
    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl)","private void updateMode() {
    String mode = intent.getStringExtra(""mode"");
    if (mode != null) {
        mode = mode.substring(0, 1).toUpperCase() + mode.substring(1);
        modeText.setText(mode);
        setTitle(getString(R.string.title_mode) + "" "" + mode);
    }
}",24.97455164392998,0.6240763516816976,31.02016197006999,23.809523809523807,44.44444444444444
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    if (chronometer == null) {
        chronometer = new Chronometer();
    }
    return chronometer;
}
 
private Chronometer chronometer;
 
public void start() {
    chronometer.start();
}
 
public void stop() {
    chronometer.stop();
}
 
public long getElapsedTime() {
    return chronometer.getElapsedTime();
}
 
public void reset() {
    chronometer.reset();
}
 
private class Chronometer {
    private long startTime;
    private long endTime;
    private boolean running;
 
    public Chronometer() {
        startTime = 0;
        endTime = 0;
        running = false;
    }
 
    public void start() {
        startTime = System.currentTimeMillis();
        running = true;
    }
 
    public void stop() {
        endTime = System.currentTimeMillis();
        running = false;
    }
 
    public long getElapsedTime() {
        if (running) {
            return System.currentTimeMillis() - startTime;
        } else {
            return endTime - startTime;
        }
    }
 
    public void reset() {
        startTime = 0;
        endTime = 0;
        running = false;
    }
}","private Chronometer getChronometer() {
    if (chronometer == null) {
        chronometer = new Chronometer();
    }
    return chronometer;
}

private Chronometer chronometer;

public void start() {
    chronometer.start();
}

public void stop() {
    chronometer.stop();
}

public long getElapsedTime() {
    return chronometer.getElapsedTime();
}

public void reset() {
    chronometer.reset();
}

private class Chronometer {
    private long startTime;
    private long endTime;
    private boolean running;

    public Chronometer() {
        startTime = 0;
        endTime = 0;
        running = false;
    }

    public void start() {
        startTime = System.currentTimeMillis();
        running = true;
    }

    public void stop() {
        endTime = System.currentTimeMillis();
        running = false;
    }

    public long getElapsedTime() {
        if (running) {
            return System.currentTimeMillis() - startTime;
        } else {
            return endTime - startTime;
        }
    }

    public void reset() {
        startTime = 0;
        endTime = 0;
        running = false;
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    sort(arr.begin(), arr.end());

    int count = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i + 1] - arr[i] <= k) {
            count++;
        }
    }

    cout << count << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    sort(arr.begin(), arr.end());

    int count = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i + 1] - arr[i] <= k) {
            count++;
        }
    }

    cout << count << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    sort(arr.begin(), arr.end());

    int count = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i + 1] - arr[i] <= k) {
            count++;
        }
    }

    cout << count << endl;

    return 0;",35.92704800169328,4.106381386204493,28.063349082107088,26.923076923076923,84.61538461538461
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
    Bitmap blurredBitmap = Bitmap.createScaledBitmap(
            BitmapFactory.decodeResource(getResources(), R.drawable.card_background),
            (int) getResources().getDimension(R.dimen.card_width),
            (int) getResources().getDimension(R.dimen.card_height),
            true);

    ImageView imageView = new ImageView(getContext());
    imageView.setImageBitmap(blurredBitmap);
    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
    imageView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return imageView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum += arr[i];
        } else {
            if (arr[i] > arr[i - 1]) {
                current_sum += arr[i];
            } else {
                max_sum = max(max_sum, current_sum);
                current_sum = arr[i];
            }
        }
    }
    max_sum = max(max_sum, current_sum);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum += arr[i];
        } else {
            if (arr[i] > arr[i - 1]) {
                current_sum += arr[i];
            } else {
                max_sum = max(max_sum, current_sum);
                current_sum = arr[i];
            }
        }
    }
    max_sum = max(max_sum, current_sum);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr =","private View getMediaLayoutView() {
    Bitmap blurredBitmap = Bitmap.createScaledBitmap(
            BitmapFactory.decodeResource(getResources(), R.drawable.card_background),
            (int) getResources().getDimension(R.dimen.card_width),
            (int) getResources().getDimension(R.dimen.card_height),
            true);

    ImageView imageView = new ImageView(getContext());
    imageView.setImageBitmap(blurredBitmap);
    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
    imageView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return imageView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum += arr[i];
        } else {
            if (arr[i] > arr[i - 1]) {
                current_sum += arr[i];
            } else {
                max_sum = max(max_sum, current_sum);
                current_sum = arr[i];
            }
        }
    }
    max_sum = max(max_sum, current_sum);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    cout << ""Sum of all elements: "" << sum << endl;

    int max_sum = 0;
    int current_sum = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            current_sum += arr[i];
        } else {
            if (arr[i] > arr[i - 1]) {
                current_sum += arr[i];
            } else {
                max_sum = max(max_sum, current_sum);
                current_sum = arr[i];
            }
        }
    }
    max_sum = max(max_sum, current_sum);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr =",26.054997047029456,1.1050998267708496,11.615289323656508,60.46511627906976,31.03448275862069
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();
    int height = image.getIntrinsicHeight();
    int scale = Math.min(width, height);
    int blurRadius = Math.max(width, height) / 2;
    Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(blurredBitmap);
    Paint paint = new Paint();
    paint.setXfermode(new BlurMaskFilter(blurRadius, BlurMaskFilter.Blur.NORMAL));
    canvas.drawBitmap(image, 0, 0, paint);
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, scale, scale, true);
    image.setBounds(0, 0, scale, scale);
}

```java
private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();
    int height = image.getIntrinsicHeight();
    int scale = Math.min(width, height);
    int blurRadius = Math.max(width, height) / 2;
    Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(blurredBitmap);
    Paint paint = new Paint();
    paint.setXfermode(new BlurMaskFilter(blurRadius, BlurMaskFilter.Blur.NORMAL));
    canvas.drawBitmap(image, 0, 0, paint);
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, scale, scale, true);
    image.setBounds(0, 0, scale, scale);
}
```

```java
private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();
    int height = image.getIntrinsicHeight();
    int scale = Math.min(width, height);
    int blurRadius = Math.max(width, height) / 2;
    Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(blurredBitmap);
    Paint paint = new Paint();
    paint.setXfermode(new BlurMaskFilter(blurRadius, BlurMaskFilter.Blur.NORMAL));
    canvas.drawBitmap(image, 0, 0, paint);
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, scale, scale, true);
    image.setBounds(0, 0, scale, scale);
}
```

```java
private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();
    int height = image.getIntrinsicHeight();
    int scale = Math.min(width, height);
    int blurRadius = Math.max(width, height) / 2;
    Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(blurredBitmap);
    Paint paint = new Paint();
    paint.setXfermode(new BlurMaskFilter(blurRadius, BlurMaskFilter.Blur.NORMAL));
    canvas.drawBitmap(image, 0, 0, paint);
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, scale, scale, true);
    image.setBounds(0, 0, scale, scale);
}
```

```java
private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();","private void updateBackgroundImage(Drawable image) {
    int width = image.getIntrinsicWidth();
    int height = image.getIntrinsicHeight();
    int scale = Math.min(width, height);
    int blurRadius = Math.max(width, height) / 2;
    Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(blurredBitmap);
    Paint paint = new Paint();
    paint.setXfermode(new BlurMaskFilter(blurRadius, BlurMaskFilter.Blur.NORMAL));
    canvas.drawBitmap(image, 0, 0, paint);
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, scale, scale, true);
    image.setBounds(0, 0, scale, scale);
}",31.184852156685434,1.9543586244390319,12.314964532217228,32.69230769230769,77.77777777777779
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaView.setVisibility(View.VISIBLE);
    mediaView.setTitle(title);
    mediaView.setSubtitle(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaView.setVisibility(View.VISIBLE);
    mediaView.setTitle(title);
    mediaView.setSubtitle(subtitle);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    cout << ""Maximum sum such that no two elements are adjacent: "" << ((incl > excl) ? incl : excl) << endl;

    // Check for Majority Element in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }
    cout << ""Is "" << x << "" a majority element? "" << (isMajority ? ""Yes"" : ""No"") << endl;

    // Find a pair with the given difference
    int diff = 3;
    int size = arr.size();
    int i = 0, j = 1;

    bool foundPair = false;
    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }
    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum such that no two elements are adjacent
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    cout << ""Maximum sum such that no two elements are adjacent: "" << ((incl > excl) ? incl : excl) << endl;

    // Check for Majority",70.842490254843,59.004687263928076,61.207379018601806,63.1578947368421,100.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        content.startChronometer();
    } else {
        content.hideChronometer();
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        content.startChronometer();
    } else {
        content.hideChronometer();
    }
}",38.50772050053479,52.75568628444888,55.164084606579166,31.11111111111111,15.0
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5,","public void onCallAdded(Call call) {
}
 
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = 0; j < k; j++) {
            sub_array.push_back(arr[i + j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < k; j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}
 
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6,",39.26435401720233,1.1366232451407023,32.84386974674555,23.076923076923077,100.0
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
    call.unregisterCallback();
    call.resetState();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {","public void onCallRemoved(Call call) {
    call.unregisterCallback();
    call.resetState();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int k = 3;

    vector<int> sub_array;
    for (int i = 0; i < n - k + 1; i++) {
        sub_array.clear();
        for (int j = i; j < i + k; j++) {
            sub_array.push_back(arr[j]);
        }
        sort(sub_array.begin(), sub_array.end());
        cout << ""Sub-array "" << i + 1 << "": "";
        for (int j = 0; j < sub_array.size(); j++) {
            cout << sub_array[j] << "" "";
        }
        cout << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {",27.401089526978296,1.2242622527233067,21.951524426618455,15.0,71.42857142857143
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
    phoneNumber = number;
    phoneNumberFormatted = formatPhoneNumber(number);
    phoneNumberMasked = maskPhoneNumber(phoneNumberFormatted);
    phoneNumberMaskedWithPlus = ""+"" + phoneNumberMasked;
    phoneNumberMaskedWithPlusAndCountryCode = ""+"" + countryCode + phoneNumberMasked;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtension = ""+"" + countryCode + phoneNumberMasked + extension;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountry","void updateModelWithPhoneNumber(String number) {
    phoneNumber = number;
    phoneNumberFormatted = formatPhoneNumber(number);
    phoneNumberMasked = maskPhoneNumber(phoneNumberFormatted);
    phoneNumberMaskedWithPlus = ""+"" + phoneNumberMasked;
    phoneNumberMaskedWithPlusAndCountryCode = ""+"" + countryCode + phoneNumberMasked;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtension = ""+"" + countryCode + phoneNumberMasked + extension;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCode = ""+"" + countryCode + phoneNumberMasked + extension + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode + countryCode;
    phoneNumberMaskedWithPlusAndCountryCodeAndExtensionAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountryCodeAndCountry",15.681265309001402,0.9260913520121058,13.187858772882393,11.11111111111111,37.5
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
    muteButton = (ImageButton) findViewById(R.id.mute);
    endCallButton = (ImageButton) findViewById(R.id.endCall);
    dialpadButton = (ImageButton) findViewById(R.id.dialpad);
}","private void initializeAudioControls() {
    muteButton = (ImageButton) findViewById(R.id.mute);
    endCallButton = (ImageButton) findViewById(R.id.endCall);
    dialpadButton = (ImageButton) findViewById(R.id.dialpad);
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the maximum value in an array""

**Code:**
public int findMax(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the minimum value in an array""

**Code:**
public int findMin(int[] arr) {
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return min;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the maximum value in an array""

**Code:**
public int findMax(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the minimum value in an array""

**Code:**
public int findMin(int[] arr) {
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return min;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the maximum value in an array""

**Code:**
public int findMax(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.

**Summary:**
""Find the minimum value in an array""

**",16.903004333609612,7.045506926661352,9.095922172482979,25.0,26.47058823529412
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (m_connectionStatus == DBusConnectionStatus::Available) {
        _listener(_subscription, DBusConnectionStatus::Available);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (m_connectionStatus == DBusConnectionStatus::Available) {
        _listener(_subscription, DBusConnectionStatus::Available);
    }
}",54.880724727788774,1.8320712900950893,61.16908849062524,56.52173913043478,100.0
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    if (exit_threads_.find(conn) == exit_threads_.end()) {
        exit_threads_[conn].push_back(t);
    }
}
 
std::mutex exit_mutex_;
std::unordered_map<std::uintptr_t, std::vector<std::thread>> exit_threads_;
 
void join_all_threads_on_exit() {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    for (auto const& [key, val] : exit_threads_) {
        for (auto &t : val) {
            t.join();
        }
    }
}
 
void signal_handler(int signum) {
    if (signum == SIGINT) {
        join_all_threads_on_exit();
        exit(signum);
    }
}
 
void setup_signal_handler() {
    signal(SIGINT, signal_handler);
}
 
void cleanup_signal_handler() {
    signal(SIGINT, SIG_DFL);
}
 
void init_exit_threads() {
    setup_signal_handler();
}
 
void cleanup_exit_threads() {
    join_all_threads_on_exit();
    cleanup_signal_handler();
}
 
void add_exit_thread(std::uintptr_t conn, std::thread &t) {
    joinOnExit(conn, t);
}
 
void remove_exit_thread(std::uintptr_t conn, std::thread &t) {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    if (exit_threads_.find(conn) != exit_threads_.end()) {
        auto it = std::find(exit_threads_[conn].begin(), exit_threads_[conn].end(), t);
        if (it != exit_threads_[conn].end()) {
            exit_threads_[conn].erase(it);
        }
    }
}
 
void join_exit_thread(std::uintptr_t conn, std::thread &t) {
    remove_exit_thread(conn, t);
    t.join();
}
 
void join_all_exit_threads() {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    for (auto const& [key, val] : exit_threads_) {
        for (auto &t : val) {
            t.join();
        }
    }
}
 
void cleanup_exit_threads_and_exit(int signum) {
    join_all_exit_threads();
    cleanup_signal_handler();
    exit(signum);
}
 
void init_exit_threads_and_exit(int signum) {
    init_exit_threads();
    signal(SIGINT, cleanup_exit_threads_and_exit);
}
 
void cleanup_exit_threads_and_exit() {
    join_all_exit_threads();
    cleanup_signal_handler();
    exit(0);
}
 
void init_exit_threads_and_exit() {
    init_exit_threads();
    signal(SIGINT, cleanup_exit_threads_and_exit);
}
 
void","void joinOnExit(std::uintptr_t conn, std::thread &t) {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    if (exit_threads_.find(conn) == exit_threads_.end()) {
        exit_threads_[conn].push_back(t);
    }
}

std::mutex exit_mutex_;
std::unordered_map<std::uintptr_t, std::vector<std::thread>> exit_threads_;

void join_all_threads_on_exit() {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    for (auto const& [key, val] : exit_threads_) {
        for (auto &t : val) {
            t.join();
        }
    }
}

void signal_handler(int signum) {
    if (signum == SIGINT) {
        join_all_threads_on_exit();
        exit(signum);
    }
}

void setup_signal_handler() {
    signal(SIGINT, signal_handler);
}

void cleanup_signal_handler() {
    signal(SIGINT, SIG_DFL);
}

void init_exit_threads() {
    setup_signal_handler();
}

void cleanup_exit_threads() {
    join_all_threads_on_exit();
    cleanup_signal_handler();
}

void add_exit_thread(std::uintptr_t conn, std::thread &t) {
    joinOnExit(conn, t);
}

void remove_exit_thread(std::uintptr_t conn, std::thread &t) {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    if (exit_threads_.find(conn) != exit_threads_.end()) {
        auto it = std::find(exit_threads_[conn].begin(), exit_threads_[conn].end(), t);
        if (it != exit_threads_[conn].end()) {
            exit_threads_[conn].erase(it);
        }
    }
}

void join_exit_thread(std::uintptr_t conn, std::thread &t) {
    remove_exit_thread(conn, t);
    t.join();
}

void join_all_exit_threads() {
    std::lock_guard<std::mutex> lock(exit_mutex_);
    for (auto const& [key, val] : exit_threads_) {
        for (auto &t : val) {
            t.join();
        }
    }
}

void cleanup_exit_threads_and_exit(int signum) {
    join_all_exit_threads();
    cleanup_signal_handler();
    exit(signum);
}

void init_exit_threads_and_exit(int signum) {
    init_exit_threads();
    signal(SIGINT, cleanup_exit_threads_and_exit);
}

void cleanup_exit_threads_and_exit() {
    join_all_exit_threads();
    cleanup_signal_handler();
    exit(0);
}

void init_exit_threads_and_exit() {
    init_exit_threads();
    signal(SIGINT, cleanup_exit_threads_and_exit);
}

void",41.82736786485963,5.189838058968687,24.52372547208111,43.47826086956522,94.11764705882352
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbus_connection_remove_watch(connection, libdbusWatch);
        libdbus_watch_unref(libdbusWatch);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int maxSum = FindMaxSum(arr, n);
    cout << ""Maximum sum such that no two elements are adjacent: "" << maxSum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int x = 5;
    bool isMajority = isMajority(arr2, n2, x);
    cout << ""Check for Majority Element in a sorted array: "" << isMajority << endl;

    int arr3[] = {1, 2, 4, 5, 7, 9};
    int size = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 3;
    bool foundPair = findPair(arr3, size, n3);
    cout << ""Find a pair with the given difference: "" << foundPair << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbus_connection_remove_watch(connection, libdbusWatch);
        libdbus_watch_unref(libdbusWatch);
    }
}",39.88781467631889,2.0315764187500958,22.51968228652545,35.0,100.0
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch->isReady()) {
        libdbusWatch->start();
    } else {
        libdbusWatch->stop();
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 5;

    bool is_majority = false;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (int i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            is_majority = true;
            break;
        }
    }

    if (is_majority) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(arr[0]);
    int n = 5;

    bool found = false;
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            found = true;
            break;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    if (!found) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch->isReady()) {
        libdbusWatch->start();
    } else {
        libdbusWatch->stop();
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 5;

    bool is_majority = false;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (int i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            is_majority = true;
            break;
        }
    }

    if (is_majority) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(arr[0]);
    int n = 5;

    bool found = false;
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            found = true;
            break;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    if (!found) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main",36.602929852596446,2.6481576766031654,15.908083878304758,39.39393939393939,88.46153846153845
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    std::lock_guard<std::mutex> lock(m_dbusObjectManagerMutex);
    if (m_dbusObjectManager == nullptr) {
        m_dbusObjectManager = std::make_shared<DBusObjectManager>(m_dbusConnection);
    }
    return m_dbusObjectManager;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int x = 2;
    bool is_majority = isMajority(arr2, n2, x);
    cout << ""Check for Majority Element in a sorted array: "" << is_majority << endl;

    int arr3[] = {1, 2, 4, 5, 7, 9};
    int size3 = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 3;
    bool found_pair = findPair(arr3, size3, n3);
    cout << ""Find a pair with the given difference: "" << found_pair << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    std::lock_guard<std::mutex> lock(m_dbusObjectManagerMutex);
    if (m_dbusObjectManager == nullptr) {
        m_dbusObjectManager = std::make_shared<DBusObjectManager>(m_dbusConnection);
    }
    return m_dbusObjectManager;
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int x = 2;
    bool is_majority = isMajority(arr2, n2, x);
    cout << ""Check for Majority Element in a sorted array: "" << is_majority << endl;

    int arr3[] = {1, 2, 4, 5, 7, 9};
    int size3 = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 3;
    bool found_pair = findPair(arr3, size3, n3);
    cout << ""Find a pair with the given difference: "" << found_pair << endl;

    return 0;
}

#include <iostream>
#include <",33.401567550929585,1.2090063188172204,23.422904910542144,58.97435897435898,50.0
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    if (serviceName.empty()) {
        return false;
    }

    std::unique_lock<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it == serviceNames_.end()) {
        return false;
    }

    if (it->second == 1) {
        serviceNames_.erase(it);
        return true;
    }

    it->second--;
    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int x = 5;
    bool is_majority = isMajority(arr2, n2, x);
    cout << ""Check for Majority Element in a sorted array: "" << is_majority << endl;

    int arr3[] = {1, 2, 4, 5, 7, 9};
    int size3 = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 2;
    bool found_pair = findPair(arr3, size3, n3);
    cout << ""Find a pair with the given difference: "" << found_pair << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        }","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    if (serviceName.empty()) {
        return false;
    }

    std::unique_lock<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it == serviceNames_.end()) {
        return false;
    }

    if (it->second == 1) {
        serviceNames_.erase(it);
        return true;
    }

    it->second--;
    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}


int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int x = 5;
    bool is_majority = isMajority(arr2, n2, x);
    cout << ""Check for Majority Element in a sorted array: "" << is_majority << endl;

    int arr3[] = {1, 2, 4, 5, 7, 9};
    int size3 = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 2;
    bool found_pair = findPair(arr3, size3, n3);
    cout << ""Find a pair with the given difference: "" << found_pair << endl;",41.714562234893556,2.9580777901009205,19.614456863759003,64.28571428571429,80.0
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    DBusMessage message;
    DBusError error;
    DBusMessage* dbusMessage = dbus_pending_call_get_reply(_libdbusPendingCall, &error);
    if (dbusMessage) {
        message.set_message(dbusMessage);
        dbus_message_unref(dbusMessage);
    }
    return message;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    DBusMessage message;
    DBusError error;
    DBusMessage* dbusMessage = dbus_pending_call_get_reply(_libdbusPendingCall, &error);
    if (dbusMessage) {
        message.set_message(dbusMessage);
        dbus_message_unref(dbusMessage);
    }
    return message;
}",35.39116361590802,0.9540439834593586,10.482405351967596,38.46153846153847,91.66666666666666
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> itsLock(m_asyncHandlersMutex);
    for (auto it = m_asyncHandlers.begin(); it != m_asyncHandlers.end(); ++it) {
        delete *it;
    }
    m_asyncHandlers.clear();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    vector<int> arr2 = {3, 1, 2, 2, 1};
    int n2 = arr2.size();
    int x2 = 2;

    if (isMajority(arr2, n2, x2)) {
        cout << x2 << "" is a majority element"" << endl;
    } else {
        cout << x2 << "" is not a majority element"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5};
    int n3 = arr3.size();
    int x3 = 6;

    if (isMajority(arr3, n3, x3)) {
        cout << x3 << "" is a majority element"" << endl;
    } else {
        cout << x3 << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 2;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = arr2.size();
    int diff2 = 11;

    if (findPair(arr2, n2, diff2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> itsLock(m_asyncHandlersMutex);
    for (auto it = m_asyncHandlers.begin(); it != m_asyncHandlers.end(); ++it) {
        delete *it;
    }
    m_asyncHandlers.clear();
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    vector<int> arr2 = {3, 1, 2, 2, 1};
    int n2 = arr2.size();
    int x2 = 2;

    if (isMajority(arr2, n2, x2)) {
        cout << x2 << "" is a majority element"" << endl;
    } else {
        cout << x2 << "" is not a majority element"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5};
    int n3 = arr3.size();
    int x3 = 6;

    if (isMajority(arr3, n3, x3)) {
        cout << x3 << "" is a majority element"" << endl;
    } else {
        cout << x3 << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 2;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = arr2.size();
    int diff2 = 11;

    if (findPair(arr2, n2, diff2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
}

bool findPair",32.15142051967367,0.6448904970827937,8.40296845236017,61.224489795918366,58.333333333333336
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    for (auto it = signalStates.begin(); it != signalStates.end(); it++) {
        if (it->second.state == DBus::State::Received) {
            it->second.state = DBus::State::Processed;
            signalHandlers[it->first](it->second.message);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum such that no two elements are adjacent: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 5;

    bool is_majority = false;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (int i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            is_majority = true;
            break;
        }
    }

    if (is_majority) {
        cout << ""Majority element "" << x << "" found in the array."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found in the array."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(arr[0]);
    int n = 5;

    bool found = false;
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            found = true;
            break;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    if (!found) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector","void DBusConnection::handleSignalStates() {
    for (auto it = signalStates.begin(); it != signalStates.end(); it++) {
        if (it->second.state == DBus::State::Received) {
            it->second.state = DBus::State::Processed;
            signalHandlers[it->first](it->second.message);
        }
    }
}",22.179823646111902,0.5826810313901812,7.701830944361772,30.434782608695656,50.0
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = itsConnections.find(_connectionId);
    if (it != itsConnections.end()) {
        itsConnections.erase(it);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = itsConnections.find(_connectionId);
    if (it != itsConnections.end()) {
        itsConnections.erase(it);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found"" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found"" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found"" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last",59.67147183230757,24.94174717700826,26.244140152221984,100.0,87.5
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getType() == DBusMessage::Type::MethodCall) {
        if (dbusMessage.getInterface() == ""org.freedesktop.DBus"") {
            if (dbusMessage.getMethodName() == ""NameOwnerChanged"") {
                if (dbusMessage.getArguments().size() == 3) {
                    const std::string_view name = dbusMessage.getArguments()[0].asString();
                    const std::string_view oldOwner = dbusMessage.getArguments()[1].asString();
                    const std::string_view newOwner = dbusMessage.getArguments()[2].asString();

                    if (name == dbusInstanceName_) {
                        if (oldOwner == """") {
                            onInstanceAdded(dbusMessage.getReplySerial());
                        } else if (newOwner == """") {
                            onInstanceRemoved(dbusMessage.getReplySerial());
                        } else {
                            onInstanceChanged(dbusMessage.getReplySerial(), oldOwner, newOwner);
                        }
                    }
                }
            }
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum such that no two elements are adjacent: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 5;

    bool isMajority = isMajority(arr, n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found in the array."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found in the array."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getType() == DBusMessage::Type::MethodCall) {
        if (dbusMessage.getInterface() == ""org.freedesktop.DBus"") {
            if (dbusMessage.getMethodName() == ""NameOwnerChanged"") {
                if (dbusMessage.getArguments().size() == 3) {
                    const std::string_view name = dbusMessage.getArguments()[0].asString();
                    const std::string_view oldOwner = dbusMessage.getArguments()[1].asString();
                    const std::string_view newOwner = dbusMessage.getArguments()[2].asString();

                    if (name == dbusInstanceName_) {
                        if (oldOwner == """") {
                            onInstanceAdded(dbusMessage.getReplySerial());
                        } else if (newOwner == """") {
                            onInstanceRemoved(dbusMessage.getReplySerial());
                        } else {
                            onInstanceChanged(dbusMessage.getReplySerial(), oldOwner, newOwner);
                        }
                    }
                }
            }
        }
    }
}",45.86904185334901,1.9919778866061673,42.09025013285051,39.39393939393939,100.0
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    _status = CommonAPI::CallStatus::SUCCESS;
    _availableServiceInstances.clear();

    std::lock_guard<std::mutex> itsLock(itsMutex);

    for (auto const& [serviceName, instances] : itsServiceInstances) {
        for (auto const& instance : instances) {
            _availableServiceInstances.push_back(instance);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 3;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No pair found."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    _status = CommonAPI::CallStatus::SUCCESS;
    _availableServiceInstances.clear();

    std::lock_guard<std::mutex> itsLock(itsMutex);

    for (auto const& [serviceName, instances] : itsServiceInstances) {
        for (auto const& instance : instances) {
            _availableServiceInstances.push_back(instance);
        }
    }
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int x = 5;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << ""Majority element "" << x << "" found."" << endl;
    } else {
        cout << ""Majority element "" << x << "" not found."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 3;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No pair found."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements is: ",36.13397083043793,1.0277986423819,20.780811952097086,72.72727272727273,50.0
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    std::shared_ptr<DBusProxy> proxy = std::make_shared<DBusProxy>(connection, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusObject> object = std::make_shared<DBusObject>(connection, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"");
    std::shared_ptr<DBusMethod> method = std::make_shared<DBusMethod>(object, ""Introspect"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusReply> reply = std::make_shared<DBusReply>();
    std::shared_ptr<DBusMessage> message = std::make_shared<DBusMessage>();
    std::shared_ptr<DBusError> error = std::make_shared<DBusError>();
    std::shared_ptr<DBusConnection> connection2 = std::make_shared<DBusConnection>();
    std::shared_ptr<DBusProxy> proxy2 = std::make_shared<DBusProxy>(connection2, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusObject> object2 = std::make_shared<DBusObject>(connection2, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"");
    std::shared_ptr<DBusMethod> method2 = std::make_shared<DBusMethod>(object2, ""Get"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusReply> reply2 = std::make_shared<DBusReply>();
    std::shared_ptr<DBusMessage> message2 = std::make_shared<DBusMessage>();
    std::shared_ptr<DBusError> error2 = std::make_shared<DBusError>();
    std::string interfaceName;
    std::string serviceName;
    std::string servicePath;
    std::string serviceInstance;
    std::string serviceVersion;
    std::string serviceDomain;
    std::string serviceUniqueName;
    std::string serviceUniqueNameVersion;
    std::string serviceUniqueNameVersionDomain;
    std::string serviceUniqueNameVersionDomainVersion;
    std::string serviceUniqueNameVersionDomainVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterface;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersion","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    std::shared_ptr<DBusProxy> proxy = std::make_shared<DBusProxy>(connection, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusObject> object = std::make_shared<DBusObject>(connection, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"");
    std::shared_ptr<DBusMethod> method = std::make_shared<DBusMethod>(object, ""Introspect"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusReply> reply = std::make_shared<DBusReply>();
    std::shared_ptr<DBusMessage> message = std::make_shared<DBusMessage>();
    std::shared_ptr<DBusError> error = std::make_shared<DBusError>();
    std::shared_ptr<DBusConnection> connection2 = std::make_shared<DBusConnection>();
    std::shared_ptr<DBusProxy> proxy2 = std::make_shared<DBusProxy>(connection2, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusObject> object2 = std::make_shared<DBusObject>(connection2, ""org.freedesktop.DBus"", ""/org/freedesktop/DBus"");
    std::shared_ptr<DBusMethod> method2 = std::make_shared<DBusMethod>(object2, ""Get"", ""org.freedesktop.DBus.Introspectable"");
    std::shared_ptr<DBusReply> reply2 = std::make_shared<DBusReply>();
    std::shared_ptr<DBusMessage> message2 = std::make_shared<DBusMessage>();
    std::shared_ptr<DBusError> error2 = std::make_shared<DBusError>();
    std::string interfaceName;
    std::string serviceName;
    std::string servicePath;
    std::string serviceInstance;
    std::string serviceVersion;
    std::string serviceDomain;
    std::string serviceUniqueName;
    std::string serviceUniqueNameVersion;
    std::string serviceUniqueNameVersionDomain;
    std::string serviceUniqueNameVersionDomainVersion;
    std::string serviceUniqueNameVersionDomainVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterface;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersionPath;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersionPathVersionPathVersion;
    std::string serviceUniqueNameVersionDomainVersionPathInterfaceVersionPathVersion",27.205770175417754,5.130093468580355,18.07207220041093,41.17647058823529,44.44444444444444
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    if (_message.getInterface() == ""org.freedesktop.DBus"") {
        if (_message.getType() == DBusMessage::MethodCall) {
            DBusMessage reply(_message.getReplyPath(), _message.getReplyName(), _message.getReplyAddress(), DBusMessage::NoReplyRequested, DBusMessage::NoError);
            reply.setInterface(_message.getInterface());
            reply.setMethod(_message.getMethod());
            reply.setArguments(_message.getArguments());
            _dbusConnection.send(reply);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum such that no two elements are adjacent: "" << maxSum << endl;

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr2) / sizeof(arr2[0]);
    int x = 5;

    bool isMajority = isMajority(arr2, size, x);

    cout << ""Is "" << x << "" a majority element in the sorted array? "" << (isMajority ? ""Yes"" : ""No"") << endl;

    int arr3[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size3 = sizeof(arr3) / sizeof(arr3[0]);
    int n3 = 5;

    bool foundPair = findPair(arr3, size3, n3);

    cout << ""Pair with difference "" << n3 << "" found? "" << (foundPair ? ""Yes"" : ""No"") << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    if (_message.getInterface() == ""org.freedesktop.DBus"") {
        if (_message.getType() == DBusMessage::MethodCall) {
            DBusMessage reply(_message.getReplyPath(), _message.getReplyName(), _message.getReplyAddress(), DBusMessage::NoReplyRequested, DBusMessage::NoError);
            reply.setInterface(_message.getInterface());
            reply.setMethod(_message.getMethod());
            reply.setArguments(_message.getArguments());
            _dbusConnection.send(reply);
        }
    }
}",34.613245539973526,1.8316459201462558,9.698259316670908,38.46153846153847,88.46153846153845
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::shared_ptr<DBusInstanceAvailabilityStatusChangedEvent> event = std::make_shared<DBusInstanceAvailabilityStatusChangedEvent>();
    event->set_object_path(_objectPath);
    event->set_interface_name(_interfaceName);
    event->set_availability(_availability);
    CommonAPI::get()->getDBusEventDispatcher()->dispatch(event);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::shared_ptr<DBusInstanceAvailabilityStatusChangedEvent> event = std::make_shared<DBusInstanceAvailabilityStatusChangedEvent>();
    event->set_object_path(_objectPath);
    event->set_interface_name(_interfaceName);
    event->set_availability(_availability);
    CommonAPI::get()->getDBusEventDispatcher()->dispatch(event);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8",51.6877784836714,2.6297313302830134,38.26772406781722,65.85365853658537,100.0
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (m_listenerAddedListeners.find(_listener) == m_listenerAddedListeners.end()) {
        m_listenerAddedListeners.insert(_listener);
    }
    if (m_subscriptionAddedListeners.find(_subscription) == m_subscriptionAddedListeners.end()) {
        m_subscriptionAddedListeners.insert(_subscription);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 3;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);
    cout << ""Maximum sum is "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i <","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (m_listenerAddedListeners.find(_listener) == m_listenerAddedListeners.end()) {
        m_listenerAddedListeners.insert(_listener);
    }
    if (m_subscriptionAddedListeners.find(_subscription) == m_subscriptionAddedListeners.end()) {
        m_subscriptionAddedListeners.insert(_subscription);
    }
}",45.24600090224251,1.9480597021479518,39.03594390682206,40.0,100.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&](const Listener& listener) {
                               return listener.first == _listener && listener.second == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    cout << ""Maximum sum such that no two elements are adjacent: "" << FindMaxSum(arr, n) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

int main() {
    int arr[] = {1, 5, 3, 4, 2};
    int size = sizeof(arr) / sizeof(arr[0]);
    int n = 2;

    if (findPair(arr, size, n)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&](const Listener& listener) {
                               return listener.first == _listener && listener.second == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    cout << ""Maximum sum such that no two elements are adjacent: "" << FindMaxSum(arr, n) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

int main() {
    int arr[] = {1, 5, 3, 4, 2};
    int size = sizeof(arr) / sizeof(arr[0]);
    int n = 2;

    if (findPair(arr, size, n)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();",46.1340327609972,2.2867573457428247,30.76127846015073,72.91666666666666,78.57142857142857
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}
 
void DBusProxyBase::removeSignalStateHandler(const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_subscription);
}

void DBusProxyBase::removeSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_handler, _subscription);
}

void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers();
}

void DBusProxyBase::removeAllSignalStateHandlers(const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlers(_subscription);
}

void DBusProxyBase::removeAllSignalStateHandlers(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlers(_handler, _subscription);
}

void DBusProxyBase::addSignalHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->addSignalHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeSignalHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->removeSignalHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeAllSignalHandlers(const std::string &_interface, const std::string &_member) {
    _connection->removeAllSignalHandlers(_interface, _member);
}

void DBusProxyBase::removeAllSignalHandlers(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->removeAllSignalHandlers(_interface, _member, _handler);
}

void DBusProxyBase::removeAllSignalHandlers() {
    _connection->removeAllSignalHandlers();
}

void DBusProxyBase::addMethodHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusMethodHandler> _handler) {
    _connection->addMethodHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeMethodHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusMethodHandler> _handler) {
    _connection->removeMethodHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeAllMethodHandlers(const std::string &_interface, const std::string &_member) {
    _connection->removeAllMethodHandlers(_interface, _member);
}

void DBusProxyBase::removeAllMethodHandlers(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusMethodHandler> _handler) {
    _connection->removeAllMethodHandlers(_interface, _member, _handler);
}

void DBusProxyBase::removeAllMethodHandlers() {
    _connection->removeAllMethodHandlers();
}

void DBusProxyBase::addErrorHandler(const std::string &_interface, const std::","void DBusProxyBase::addErrorHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusErrorHandler> _handler) {
    _connection->addErrorHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeErrorHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusErrorHandler> _handler) {
    _connection->removeErrorHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeAllErrorHandlers(const std::string &_interface, const std::string &_member) {
    _connection->removeAllErrorHandlers(_interface, _member);
}

void DBusProxyBase::removeAllErrorHandlers(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusErrorHandler> _handler) {
    _connection->removeAllErrorHandlers(_interface, _member, _handler);
}

void DBusProxyBase::removeAllErrorHandlers() {
    _connection->removeAllErrorHandlers();
}

void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}

void DBusProxyBase::removeSignalStateHandler(const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_subscription);
}

void DBusProxyBase::removeSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_handler, _subscription);
}

void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers();
}

void DBusProxyBase::removeAllSignalStateHandlers(const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlers(_subscription);
}

void DBusProxyBase::removeAllSignalStateHandlers(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlers(_handler, _subscription);
}

void DBusProxyBase::addSignalHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->addSignalHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeSignalHandler(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->removeSignalHandler(_interface, _member, _handler);
}

void DBusProxyBase::removeAllSignalHandlers(const std::string &_interface, const std::string &_member) {
    _connection->removeAllSignalHandlers(_interface, _member);
}

void DBusProxyBase::removeAllSignalHandlers(const std::string &_interface, const std::string &_member, std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler) {
    _connection->removeAllSignalHandlers(_interface, _member, _handler);
}

void DBusProxyBase::removeAllSignalHandlers() {
    _connection->removeAllSignalHandlers();
}

void DBusProxyBase::addMethodHandler(const std::string &_interface, const std::string &_member, std::shared_",60.19427769670339,2.391556726167084,43.94110961620203,94.44444444444444,100.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << ""Majority element found"" << endl;
    } else {
        cout << ""Majority element not found"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 3;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);
    cout << ""Maximum sum is "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << ""Majority element found"" << endl;
    } else {
        cout << ""Majority element not found"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 3;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);
    cout << ""Maximum sum is "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (",54.47780821141785,3.6725546059955283,50.90534490634254,80.0,83.33333333333334
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getType() == DBusMessage::Type::MethodCall) {
        return handleMethodCall(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Signal) {
        return handleSignal(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Error) {
        return handleError(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Reply) {
        return handleReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::MethodReturn) {
        return handleMethodReturn(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ErrorReply) {
        return handleErrorReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Introspect) {
        return handleIntrospection(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::MethodError) {
        return handleMethodError(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::SignalReply) {
        return handleSignalReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ErrorReply) {
        return handleMethodErrorReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Dispatch) {
        return handleDispatch(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Invalid) {
        return handleInvalid(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Unknown) {
        return handleUnknown(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyRequested) {
        return handleNoReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyExpected) {
        return handleNoReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyExpected) {
        return handleReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyRequested) {
        return handleReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoAutoStart) {
        return handleNoAutoStart(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::AutoStart) {
        return handleAutoStart(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyRequested) {
        return handleNoReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyExpected) {
        return handleNoReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyExpected) {
        return handleReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyRequested) {
        return handleReplyRequested(dbusMessage);","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getType() == DBusMessage::Type::MethodCall) {
        return handleMethodCall(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Signal) {
        return handleSignal(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Error) {
        return handleError(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Reply) {
        return handleReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::MethodReturn) {
        return handleMethodReturn(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ErrorReply) {
        return handleErrorReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Introspect) {
        return handleIntrospection(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::MethodError) {
        return handleMethodError(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::SignalReply) {
        return handleSignalReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ErrorReply) {
        return handleMethodErrorReply(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Dispatch) {
        return handleDispatch(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Invalid) {
        return handleInvalid(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::Unknown) {
        return handleUnknown(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyRequested) {
        return handleNoReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyExpected) {
        return handleNoReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyExpected) {
        return handleReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyRequested) {
        return handleReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoAutoStart) {
        return handleNoAutoStart(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::AutoStart) {
        return handleAutoStart(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyRequested) {
        return handleNoReplyRequested(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::NoReplyExpected) {
        return handleNoReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyExpected) {
        return handleReplyExpected(dbusMessage);
    } else if (dbusMessage.getType() == DBusMessage::Type::ReplyRequested) {
        return handleReplyRequested(dbusMessage);
    }",26.48341686033482,2.822900016046712,7.88875970328485,30.357142857142854,64.86486486486487
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    if (dbusInterfaceHandlerPath.isValid()) {
        if (dbusInterfaceHandlerPath.isStandardInterface()) {
            if (standardInterfaceHandlers.find(dbusInterfaceHandlerPath) == standardInterfaceHandlers.end()) {
                standardInterfaceHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                return true;
            }
        } else {
            if (dbusInterfaceHandlerPath.isInterface()) {
                if (interfaceHandlers.find(dbusInterfaceHandlerPath) == interfaceHandlers.end()) {
                    interfaceHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                    return true;
                }
            } else if (dbusInterfaceHandlerPath.isObject()) {
                if (objectHandlers.find(dbusInterfaceHandlerPath) == objectHandlers.end()) {
                    objectHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                    return true;
                }
            }
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new_excl = max(incl, excl);
        incl = excl + arr[i];
        excl = new_excl;
        max_sum = max(max_sum, max(incl, excl));
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    int max_sum = 0;
    int incl = 0;
    int excl = 0;

    for (int i = 0; i < n; i++) {
        int new","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    if (dbusInterfaceHandlerPath.isValid()) {
        if (dbusInterfaceHandlerPath.isStandardInterface()) {
            if (standardInterfaceHandlers.find(dbusInterfaceHandlerPath) == standardInterfaceHandlers.end()) {
                standardInterfaceHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                return true;
            }
        } else {
            if (dbusInterfaceHandlerPath.isInterface()) {
                if (interfaceHandlers.find(dbusInterfaceHandlerPath) == interfaceHandlers.end()) {
                    interfaceHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                    return true;
                }
            } else if (dbusInterfaceHandlerPath.isObject()) {
                if (objectHandlers.find(dbusInterfaceHandlerPath) == objectHandlers.end()) {
                    objectHandlers[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                    return true;
                }
            }
        }
    }
    return false;
}",39.598521114187726,3.861103350393465,20.20758428096062,48.61111111111111,85.71428571428571
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex);
    if (registeredObjectsTable.find(ifpath) == registeredObjectsTable.end()) {
        registeredObjectsTable[ifpath] = handler;
        return true;
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 1;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    vector<int> arr2 = {3, 1, 2, 2, 1};
    int n2 = arr2.size();
    int x2 = 2;

    if (isMajority(arr2, n2, x2)) {
        cout << x2 << "" is a majority element"" << endl;
    } else {
        cout << x2 << "" is not a majority element"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5};
    int n3 = arr3.size();
    int x3 = 6;

    if (isMajority(arr3, n3, x3)) {
        cout << x3 << "" is a majority element"" << endl;
    } else {
        cout << x3 << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 2;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = arr2.size();
    int diff2 = 11;

    if (findPair(arr2, n2, diff2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex);
    if (registeredObjectsTable.find(ifpath) == registeredObjectsTable.end()) {
        registeredObjectsTable[ifpath] = handler;
        return true;
    }
    return false;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();
    int diff = 2;

    if (findPair(arr, n, diff)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = arr2.size();
    int diff2 = 11;

    if (findPair(arr2, n2, diff2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    vector<int> arr3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n3 = arr3.size();
    int diff3 = 1;

    if (findPair(arr3, n3, diff3)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""No pair found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex);
    if (registeredObjectsTable.find(ifpath) == registeredObjectsTable.end()) {
        registeredObjectsTable[",36.33558498668895,3.0981621253446354,22.05140673707383,48.19277108433735,72.0
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t response[8];
    response[0] = 0x7E;
    response[1] = 0x00;
    response[2] = 0x00;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;
    response[1] = 0x01;
    response[3] = reset_type;
    response[5] = 0x01;
    response[6] = 0x00;
    response[7] = 0x00;
    send_uds_message(response, 8);
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t response[8];
    response[0] = 0x7E;
    response[1] = 0x01;
    response[2] = 0x00;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;
    response[3] = reset_type;
    response[5] = 0x01;
    response[6] = 0x00;
    response[7] = 0x00;
    send_uds_message(response, 8);
}",12.701780564429757,5.831376465417902,6.4730719955096845,9.090909090909092,29.411764705882355
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len == 0) {
        return;
    }

    if (data[0] == 0x01) {
        system(""reboot"");
    }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len == 0) {
        return;
    }

    if (data[0] == 0x01) {
        system(""reboot"");
    }
}",24.82922794613337,20.38645643094709,24.66688946211353,20.930232558139537,33.33333333333333
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
    uint8_t response[8];
    response[0] = 0x05;
    response[1] = 0x00;
    response[2] = 0x00;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;
    send_uds_message(response, 8);
}","void send_request_download_response() {
    uint8_t response[8];
    response[0] = 0x05;
    response[1] = 0x00;
    response[2] = 0x00;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;
    send_uds_message(response, 8);
}",7.512858655393967,1.686343832205101,2.115090789370763,6.25,20.0
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t response[2];
    response[0] = 0x03;
    response[1] = block_sequence_counter;
    send_uds_message(response, 2);
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t response[2];
    response[0] = 0x03;
    response[1] = block_sequence_counter;
    send_uds_message(response, 2);
}",12.262632286391009,4.328964575265184,9.42744692324003,11.76470588235294,23.52941176470588
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[2];
    data[0] = (uint8_t)(routine_id >> 8);
    data[1] = (uint8_t)routine_id;
    iso_tp_send_positive_response(data, 2, result);
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[2];
    data[0] = (uint8_t)(routine_id >> 8);
    data[1] = (uint8_t)routine_id;
    iso_tp_send_positive_response(data, 2, result);
}",18.98866219109593,5.976509819654754,11.901215867805897,23.076923076923077,35.0
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
    uint8_t buffer[8];
    uint8_t i;

    buffer[0] = 0x05;
    buffer[1] = 0x00;
    buffer[2] = 0x00;
    buffer[3] = 0x00;
    buffer[4] = 0x00;
    buffer[5] = 0x00;
    buffer[6] = 0x00;
    buffer[7] = 0x00;

    for (i = 0; i < 8; i++) {
        iso_tp_send_message(buffer + i, 1);
    }
}","static void send_transer_exit_positive_response() {
    uint8_t buffer[8];
    uint8_t i;

    buffer[0] = 0x05;
    buffer[1] = 0x00;
    buffer[2] = 0x00;
    buffer[3] = 0x00;
    buffer[4] = 0x00;
    buffer[5] = 0x00;
    buffer[6] = 0x00;
    buffer[7] = 0x00;

    for (i = 0; i < 8; i++) {
        iso_tp_send_message(buffer + i, 1);
    }
}",14.939295979096928,7.020662805379731,7.888036262523126,18.181818181818183,26.666666666666668
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t index = 0;
    uint8_t i;
    uint8_t can_id_mask = 0x0FFF;
    uint8_t can_id_shift = 0;

    if (can_id & 0x80000000) {
        index = 0x01;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x40000000) {
        index = 0x02;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x20000000) {
        index = 0x03;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x10000000) {
        index = 0x04;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x08000000) {
        index = 0x05;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x04000000) {
        index = 0x06;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x02000000) {
        index = 0x07;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x01000000) {
        index = 0x08;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00800000) {
        index = 0x09;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00400000) {
        index = 0x0A;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00200000) {
        index = 0x0B;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00100000) {
        index = 0x0C;
        can_id_mask = 0x0000FFFF;
        can_id","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t index = 0;
    uint8_t i;
    uint8_t can_id_mask = 0x0FFF;
    uint8_t can_id_shift = 0;

    if (can_id & 0x80000000) {
        index = 0x01;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x40000000) {
        index = 0x02;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x20000000) {
        index = 0x03;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x10000000) {
        index = 0x04;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x08000000) {
        index = 0x05;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x04000000) {
        index = 0x06;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x02000000) {
        index = 0x07;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x01000000) {
        index = 0x08;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00800000) {
        index = 0x09;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00400000) {
        index = 0x0A;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00200000) {
        index = 0x0B;
        can_id_mask = 0x0000FFFF;
        can_id_shift = 8;
    } else if (can_id & 0x00100000) {
        index = 0x0C;
        can_id_mask = 0x0000FFFF;
        can_id",25.005772084739537,2.7761456554039206,21.056466493078023,33.33333333333333,42.857142857142854
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev_get_drvdata(dev);
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].callback) {
				data->rx_filters[i].callback(dev, &data->rx_filters[i].filter);
				data->rx_filters[i].callback = NULL;
			}
		}
	} else {
		if (data->rx_filters[filter_id].callback) {
			data->rx_filters[filter_id].callback(dev, &data->rx_filters[filter_id].filter);
			data->rx_filters[filter_id].callback = NULL;
		}
	}
}

```c
static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev_get_drvdata(dev);
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].callback) {
				data->rx_filters[i].callback(dev, &data->rx_filters[i].filter);
				data->rx_filters[i].callback = NULL;
			}
		}
	} else {
		if (data->rx_filters[filter_id].callback) {
			data->rx_filters[filter_id].callback(dev, &data->rx_filters[filter_id].filter);
			data->rx_filters[filter_id].callback = NULL;
		}
	}
}
```

```c
static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev_get_drvdata(dev);
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].callback) {
				data->rx_filters[i].callback(dev, &data->rx_filters[i].filter);
				data->rx_filters[i].callback = NULL;
			}
		}
	} else {
		if (data->rx_filters[filter_id].callback) {
			data->rx_filters[filter_id].callback(dev, &data->rx_filters[filter_id].filter);
			data->rx_filters[filter_id].callback = NULL;
		}
	}
}
```

```c
static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev_get_drvdata(dev);
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].callback) {
				data->rx_filters[i].callback(dev, &data->rx","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev_get_drvdata(dev);
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].callback) {
				data->rx_filters[i].callback(dev, &data->rx_filters[i].filter);
				data->rx_filters[i].callback = NULL;
			}
		}
	} else {
		if (data->rx_filters[filter_id].callback) {
			data->rx_filters[filter_id].callback(dev, &data->rx_filters[filter_id].filter);
			data->rx_filters[filter_id].callback = NULL;
		}
	}
}",41.86780792887191,8.980452485393085,41.72059289469085,42.857142857142854,73.91304347826086
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_context *ctx = (struct lin_context *)user_data;
    struct lin_frame *out_frame;

    if (ctx->state != LIN_STATE_IDLE) {
        return false;
    }

    if (ctx->out_frame_queue.head == NULL) {
        return false;
    }

    out_frame = list_pop_front(&ctx->out_frame_queue);

    if (out_frame->callback) {
        out_frame->callback(out_frame->user_data);
    }

    return true;
}
docs/api/c/linux/v4l2-controls.md
# V4L2 Controls

## Overview

The V4L2 API provides a mechanism for controlling the behavior of video devices. These controls are accessed through the `v4l2_ctrl_ops` structure, which is a member of the `v4l2_ctrl_handler` structure. The `v4l2_ctrl_handler` structure is a member of the `v4l2_device` structure.

The `v4l2_ctrl_ops` structure contains a set of function pointers that are used to access and modify the control values. The function pointers are:

* `get`: Gets the current value of the control.
* `set`: Sets the value of the control.
* `query`: Queries the range of values that the control can take.
* `ctrl_hdlr`: A pointer to the `v4l2_ctrl_handler` structure.

The `v4l2_ctrl_handler` structure contains a set of function pointers that are used to access and modify the control values. The function pointers are:

* `hdlr`: A pointer to the `v4l2_ctrl_ops` structure.
* `handler`: A pointer to the `v4l2_ctrl_handler` structure.
* `ctrls`: An array of `v4l2_ctrl` structures.

The `v4l2_ctrl` structure contains the following members:

* `id`: The control ID.
* `type`: The control type.
* `flags`: The control flags.
* `min`: The minimum value of the control.
* `max`: The maximum value of the control.
* `default`: The default value of the control.
* `step`: The step size of the control.
* `value`: The current value of the control.
* `hdlr`: A pointer to the `v4l2_ctrl_handler` structure.

## Control Types

The `v4l2_ctrl_type` enumeration defines the types of controls that can be used. The following table lists the control types and their descriptions:

| Control Type | Description |
|---|---|
| `V4L2_CTRL_TYPE_INTEGER` | The control is an integer. |
| `V4L2_CTRL_TYPE_BOOLEAN` | The control is a boolean. |
| `V4L2_CTRL_TYPE_MENU` | The control is a menu. |
| `V4L2_CTRL_TYPE_STRING` | The control is a string. |
| `V4L2_CTRL_TYPE_BYTE` | The control is a byte. |
| `V4L2_CTRL_TYPE_WORD` | The control is a word. |
| `V4L2_CTRL_TYPE_PDWORD` | The control is a pointer-sized word. |","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_context *ctx = (struct lin_context *)user_data;
    struct lin_frame *out_frame;

    if (ctx->state != LIN_STATE_IDLE) {
        return false;
    }

    if (ctx->out_frame_queue.head == NULL) {
        return false;
    }

    out_frame = list_pop_front(&ctx->out_frame_queue);

    if (out_frame->callback) {
        out_frame->callback(out_frame->user_data);
    }

    return true;
}
docs/api/c/linux/v4l2-ioctl.md
# V4L2 IOCTLs

## Overview

The V4L2 API provides a mechanism for controlling the behavior of video devices. These controls are accessed through the `ioctl` system call. The `ioctl` system call takes two arguments:

* `fd`: The file descriptor of the video device.
* `request`: The `ioctl` request code.

The `ioctl` request code is a 32-bit value that specifies the operation to be performed. The `ioctl` request code is defined in the `ioctl` header file.

The `ioctl` system call returns 0 on success and -1 on failure. On failure, the `errno` variable is set to indicate the error.

## IOCTL Request Codes

The `ioctl` request codes are defined in the `ioctl` header file. The following table lists the `ioctl` request codes and their descriptions:

| IOCTL Request Code | Description |
|---|---|
| `VIDIOC_QUERYCAP` | Queries the capabilities of the video device. |
| `VIDIOC_QUERYCTRL` | Queries the range of values that a control can take. |
| `VIDIOC_GCTRL` | Gets the current value of a control. |
| `VIDIOC_SCTRL` | Sets the value of a control. |
| `VIDIOC_QUERYBUF` | Queries the buffer memory allocation. |
| `VIDIOC_PREPAREBUF` | Prepares a buffer for use. |
| `VIDIOC_MALLOCBUF` | Allocates a buffer for use. |
| `VIDIOC_QBUF` | Queues a buffer for use. |
| `VIDIOC_DQBUF` | Dequeues a buffer for use. |
| `VIDIOC_STREAMON` | Starts streaming. |
| `VIDIOC_STREAMOFF` | Stops streaming. |
| `VIDIOC_SELECTIO` | Selects the I/O method. |
| `VIDIOC_SBUF_TYPE` | Sets the buffer type. |
| `VIDIOC_SBUF_SIZE` | Sets the buffer size. |
| `VIDIOC_SBUF_INTERLACED` | Sets the buffer interlaced flag. |
| `VIDIOC_SBUF_TIMESTAMP` | Sets the buffer timestamp flag. |
| `VIDIOC_SBUF_TYPE` | Sets the buffer type. |
| `VIDIOC_SBUF_SIZE` | Sets the buffer size. |
| `VIDIOC_SBUF_INTERLACED` | Sets the buffer interlaced flag. |
| `VIDIOC_SBUF_TIMESTAMP` | Sets the buffer timestamp flag. |
| `VIDIOC_SBUF_TYPE` | Sets the buffer type. |
| `VIDIOC_SBUF_SIZE` | Sets the buffer size. |
| `VIDIOC_SBUF_INTERLACED` | Sets the buffer",32.89878604178529,3.0923366508114234,23.675221309433205,44.827586206896555,60.0
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    struct can_frame can_frame;
    can_frame.id = frame->id;
    can_frame.dlc = frame->length;
    memcpy(can_frame.data, frame->data, frame->length);

    can_frame_handler(user_data, &can_frame);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    struct can_frame can_frame;
    can_frame.id = frame->id;
    can_frame.dlc = frame->length;
    memcpy(can_frame.data, frame->data, frame->length);

    can_frame_handler(user_data, &can_frame);
}",20.143810537430436,3.9038427329143173,12.389790221405127,36.7816091954023,27.500000000000004
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
	int ret;
	struct hv_shield_data *data = dev_get_drvdata(dev);

	/* Initialize the shield */
	data->reg = devm_kzalloc(dev, sizeof(struct hv_shield_reg), GFP_KERNEL);
	if (!data->reg)
		return -ENOMEM;

	/* Initialize the shield registers */
	data->reg->hv_shield_enable = 0;
	data->reg->hv_shield_output_enable = 0;
	data->reg->hv_shield_output_level = 0;

	/* Enable the shield */
	data->reg->hv_shield_enable = 1;

	/* Enable the shield output */
	data->reg->hv_shield_output_enable = 1;

	/* Set the shield output level */
	data->reg->hv_shield_output_level = 1;

	/* Wait for the shield to be initialized */
	msleep(100);

	return 0;
}
docs/api/c/hv_shield.rst
=================================

.. toctree::
   :maxdepth: 2

   hv_shield_api
   hv_shield_example
   hv_shield_api_reference
   hv_shield_api_reference_c
   hv_shield_api_reference_c_structs
   hv_shield_api_reference_c_functions
   hv_shield_api_reference_c_enums
   hv_shield_api_reference_c_macros
   hv_shield_api_reference_c_typedefs
   hv_shield_api_reference_c_struct_hv_shield_data
   hv_shield_api_reference_c_struct_hv_shield_reg
   hv_shield_api_reference_c_struct_hv_shield_config
   hv_shield_api_reference_c_struct_hv_shield_init_data
   hv_shield_api_reference_c_struct_hv_shield_init_data_config
   hv_shield_api_reference_c_struct_hv_shield_init_data_data
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_enable
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_enable
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_high
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_low
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_mid
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_off
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_on","static int hv_shield_init(const struct device* dev) {
	int ret;
	struct hv_shield_data *data = dev_get_drvdata(dev);

	/* Initialize the shield */
	data->reg = devm_kzalloc(dev, sizeof(struct hv_shield_reg), GFP_KERNEL);
	if (!data->reg)
		return -ENOMEM;

	/* Enable the shield */
	data->reg->hv_shield_enable = 1;

	/* Enable the shield output */
	data->reg->hv_shield_output_enable = 1;

	/* Set the shield output level */
	data->reg->hv_shield_output_level = 1;

	/* Wait for the shield to be initialized */
	msleep(100);

	return 0;
}
docs/api/c/hv_shield.rst
=================================

.. toctree::
   :maxdepth: 2

   hv_shield_api
   hv_shield_example
   hv_shield_api_reference
   hv_shield_api_reference_c
   hv_shield_api_reference_c_structs
   hv_shield_api_reference_c_functions
   hv_shield_api_reference_c_enums
   hv_shield_api_reference_c_macros
   hv_shield_api_reference_c_typedefs
   hv_shield_api_reference_c_struct_hv_shield_data
   hv_shield_api_reference_c_struct_hv_shield_reg
   hv_shield_api_reference_c_struct_hv_shield_config
   hv_shield_api_reference_c_struct_hv_shield_init_data
   hv_shield_api_reference_c_struct_hv_shield_init_data_config
   hv_shield_api_reference_c_struct_hv_shield_init_data_data
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_enable
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_enable
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_high
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_low
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_mid
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_off
   hv_shield_api_reference_c_struct_hv_shield_init_data_data_reg_hv_shield_output_level_on
docs/api/c/hv_shield.rst
=================================

.. toctree::
   :maxdepth: 2

   hv_shield_api
   hv_shield_example
   hv_shield_api_reference
   hv_shield_",18.040517199164803,6.221881513517042,11.148228423862129,28.985507246376812,25.806451612903224
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    struct hv_shield_data* data = dev_get_drvdata(dev);
    int ret;

    if (!data) {
        dev_err(dev, ""No data found\n"");
        return -ENODEV;
    }

    if (data->reg_base + data->reg_dac_gain + dac >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 1 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 2 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 3 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 4 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 5 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 6 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 7 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 8 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 9 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 10 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 11","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    struct hv_shield_data* data = dev_get_drvdata(dev);
    int ret;

    if (!data) {
        dev_err(dev, ""No data found\n"");
        return -ENODEV;
    }

    if (data->reg_base + data->reg_dac_gain + dac >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 1 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 2 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 3 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 4 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 5 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 6 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 7 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 8 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 9 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 10 >= data->reg_end) {
        dev_err(dev, ""DAC %d out of range\n"", dac);
        return -EINVAL;
    }

    if (data->reg_base + data->reg_dac_gain + dac + 11",38.61987726711857,5.194725785578262,33.13645792404433,47.72727272727273,68.42105263157895
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    uint8_t reg = 0;
    uint8_t mask = 0x0F;
    uint8_t nibble = (index & 0x0F) << 4;
    uint8_t nibble2 = (index & 0xF0) >> 4;

    reg = (nibble | nibble2);

    if (enable) {
        reg |= (1 << index);
    } else {
        reg &= ~(1 << index);
    }

    return device_write_reg(dev, HVS_GPIO_OUTPUT_ENABLE_REG, reg);
}
docs/api/c/index.rst
# C API Reference

.. toctree::
   :maxdepth: 2

   gpio
   interrupt
   timer
   spi
   i2c
   uart
   flash
   dma
   interrupt
   memory
   mutex
   semaphore
   thread
   event
   mailbox
   watchdog
   heap
   shell
   filesystem
   network
   usb
   camera
   display
   audio
   sensor
   power
   system
   debug
   trace
   test
   examples
   faq
   glossary
   api_reference_index
   api_reference_index_alphabetical
   api_reference_index_by_category
   api_reference_index_by_module
   api_reference_index_by_file
   api_reference_index_by_function
   api_reference_index_by_struct
   api_reference_index_by_enum
   api_reference_index_by_macro
   api_reference_index_by_typedef
   api_reference_index_by_union
   api_reference_index_by_namespace
   api_reference_index_by_header
   api_reference_index_by_source
   api_reference_index_by_include
   api_reference_index_by_license
   api_reference_index_by_version
   api_reference_index_by_date
   api_reference_index_by_author
   api_reference_index_by_maintainer
   api_reference_index_by_contributor
   api_reference_index_by_status
   api_reference_index_by_deprecated
   api_reference_index_by_experimental
   api_reference_index_by_unstable
   api_reference_index_by_private
   api_reference_index_by_internal
   api_reference_index_by_public
   api_reference_index_by_deprecated_since
   api_reference_index_by_deprecated_until
   api_reference_index_by_experimental_since
   api_reference_index_by_experimental_until
   api_reference_index_by_unstable_since
   api_reference_index_by_unstable_until
   api_reference_index_by_private_since
   api_reference_index_by_private_until
   api_reference_index_by_internal_since
   api_reference_index_by_internal_until
   api_reference_index_by_public_since
   api_reference_index_by_public_until
   api_reference_index_by_deprecated_version
   api_reference_index_by_experimental_version
   api_reference_index_","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    uint8_t reg = 0;
    uint8_t mask = 0x0F;
    uint8_t nibble = (index & 0x0F) << 4;
    uint8_t nibble2 = (index & 0xF0) >> 4;

    reg = (nibble | nibble2);

    if (enable) {
        reg |= (1 << index);
    } else {
        reg &= ~(1 << index);
    }

    return device_write_reg(dev, HVS_GPIO_OUTPUT_ENABLE_REG, reg);
}
docs/api/c/gpio.rst
.. automodule:: Zephyr.GPIO

.. currentmodule:: Zephyr.GPIO

.. moduleauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   - Sebastian Keller <sebastian.keller@t-mobile.de>

.. sectionauthor::
   -",33.620354798102575,12.135275450353884,30.836709779792265,41.509433962264154,50.0
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    struct can_frame can_frame;
    struct can_device *can_dev = (struct can_device *)user_data;

    can_frame.id = frame->id;
    can_frame.dlc = frame->dlc;
    memcpy(can_frame.data, frame->data, frame->dlc);

    can_device_transmit(can_dev->device, &can_frame);
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API for the Linux kernel's CAN bus driver.

## Overview

The CAN bus driver provides a generic interface for accessing CAN controllers. It supports the following features:

*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    struct can_frame can_frame;
    struct can_device *can_dev = (struct can_device *)user_data;

    can_frame.id = frame->id;
    can_frame.dlc = frame->dlc;
    memcpy(can_frame.data, frame->data, frame->dlc);

    can_device_transmit(can_dev->device, &can_frame);
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API for the Linux kernel's CAN bus driver.

## Overview

The CAN bus driver provides a generic interface for accessing CAN controllers. It supports the following features:

*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
*   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on a single system.
*   **Multiple CAN networks:** The driver can manage multiple CAN networks on a single system.
*   **Multiple CAN interfaces:** The driver can manage multiple CAN interfaces on a single system.
*   **Multiple CAN devices:** The driver can manage multiple CAN devices on a single system.
*   **Multiple CAN messages:** The driver can manage multiple CAN messages on a single system.
*   **Multiple CAN frames:** The driver can manage multiple CAN frames on a single system.
 *   **Multiple CAN controllers:** The driver can manage multiple CAN controllers on",37.30731381342316,2.1107484854082923,27.11850676828435,45.0,75.0
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_router_add_entry(entries[i].interface_id, entries[i].can_id, entries[i].mask, entries[i].target_interface_id) != 0) {
            return -1;
        }
    }
    return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_router_add_entry(entries[i].interface_id, entries[i].can_id, entries[i].mask, entries[i].target_interface_id) != 0) {
            return -1;
        }
    }
    return 0;
}",40.52657778536438,28.9885526563602,33.0033420091248,36.95652173913043,63.1578947368421
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
    int i;

    for (i = 0; i < MAX_STATIC_ROUTES; i++) {
        if (static_routes[i].bus != 0) {
            if (can_router_register_route(static_routes[i].bus,
                                          static_routes[i].can_id,
                                          static_routes[i].dst_bus,
                                          static_routes[i].dst_can_id) != 0) {
                printk(KERN_ERR ""can_router_register_route failed\n"");
                return -1;
            }
        }
    }

    return 0;
}","static int can_router_sysinit() {
    int i;

    for (i = 0; i < MAX_STATIC_ROUTES; i++) {
        if (static_routes[i].bus != 0) {
            if (can_router_register_route(static_routes[i].bus,
                                          static_routes[i].can_id,
                                          static_routes[i].dst_bus,
                                          static_routes[i].dst_can_id) != 0) {
                printk(KERN_ERR ""can_router_register_route failed\n"");
                return -1;
            }
        }
    }

    return 0;
}",26.264569106358998,17.377208785560804,23.887964191599316,13.793103448275861,50.0
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < GPIO_NUM_PINS; i++) {
		if ((mask >> i) & 1) {
			ret = gpio_set_pin(port, i, (value >> i) & 1);
			if (ret) {
				return ret;
			}
		}
	}

	return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < GPIO_NUM_PINS; i++) {
		if ((mask >> i) & 1) {
			ret = gpio_set_pin(port, i, (value >> i) & 1);
			if (ret) {
				return ret;
			}
		}
	}

	return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.",37.0059862067758,33.477141207724976,35.27692095966506,25.423728813559322,53.84615384615385
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (dev == NULL || free_slots == NULL) {
        return -EINVAL;
    }

    if (dev->cb_slots_used == 0) {
        *free_slots = dev->cb_slots_max;
    } else {
        *free_slots = dev->cb_slots_max - dev->cb_slots_used;
    }

    return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (dev == NULL || free_slots == NULL) {
        return -EINVAL;
    }

    *free_slots = dev->cb_slots_max - dev->cb_slots_used;

    return 0;
}",53.174534082719106,35.75978348592434,50.2716861782854,66.66666666666666,60.0
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_device *device = dev->data;
    struct al_incoming_cb *cb = NULL;
    int ret = -ENOMEM;

    if (device == NULL) {
        return -EINVAL;
    }

    cb = kzalloc(sizeof(struct al_incoming_cb), GFP_KERNEL);
    if (cb == NULL) {
        return -ENOMEM;
    }

    cb->callback = callback;
    cb->user_data = user_data;
    cb->frame_id = frame_id;
    cb->frame_size = frame_size;

    spin_lock(&device->incoming_cb_lock);
    list_add_tail(&cb->list, &device->incoming_cb_list);
    spin_unlock(&device->incoming_cb_lock);

    return 0;
}

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/list.h>
#include <linux/spinlock.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/kthread.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/netdevice.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/netlink.h>
#include <linux/skbuff.h>
#include <linux/scatterlist.h>
#include <linux/version.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <linux/ip.h>
#include <linux/icmp.h>
#include <linux/icmpv6.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/seq_file.h>
#include <linux/seq_file_net.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/netfilter/nf_conntrack.h>
#include <linux/netfilter/nf_conntrack_common.h>
#include <linux/netfilter/nf_conntrack_ip.h>
#include <linux/netfilter/nf_conntrack_proto_ipv4.h>
#include <linux/netfilter/nf_conntrack_proto_ipv6.h>
#include <linux/netfilter/nf_conntrack_proto_icmp.h>
#include <linux/netfilter/nf_conntrack_proto_icmpv6.h>
#include <linux/netfilter/nf_conntrack_proto_tcp.h>
#include <linux/netfilter/nf_conntrack_proto_udp.h>
#include <linux/netfilter/nf_conntrack_proto_gre.h>
#include <linux/netfilter/nf_conntrack_proto_sctp.h>
#include <linux/netfilter/nf_conntrack_proto_dccp.h","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_device *device = dev->data;
    struct al_incoming_cb *cb = NULL;
    int ret = -ENOMEM;

    if (device == NULL) {
        return -EINVAL;
    }

    cb = kzalloc(sizeof(struct al_incoming_cb), GFP_KERNEL);
    if (cb == NULL) {
        return -ENOMEM;
    }

    cb->callback = callback;
    cb->user_data = user_data;
    cb->frame_id = frame_id;
    cb->frame_size = frame_size;

    spin_lock(&device->incoming_cb_lock);
    list_add_tail(&cb->list, &device->incoming_cb_list);
    spin_unlock(&device->incoming_cb_lock);

    return 0;
}

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/list.h>
#include <linux/spinlock.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/kthread.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/netdevice.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/netlink.h>
#include <linux/skbuff.h>
#include <linux/scatterlist.h>
#include <linux/version.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <linux/ip.h>
#include <linux/icmp.h>
#include <linux/icmpv6.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/seq_file.h>
#include <linux/seq_file_net.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/netfilter/nf_conntrack.h>
#include <linux/netfilter/nf_conntrack_common.h>
#include <linux/netfilter/nf_conntrack_ip.h>
#include <linux/netfilter/nf_conntrack_proto_ipv4.h>
#include <linux/netfilter/nf_conntrack_proto_ipv6.h>
#include <linux/netfilter/nf_conntrack_proto_icmp.h>
#include <linux/netfilter/nf_conntrack_proto_icmpv6.h>
#include <linux/netfilter/nf_conntrack_proto_tcp.h>
#include <linux/netfilter/nf_conntrack_proto_udp.h>
#include <linux/netfilter/nf_conntrack_proto_gre.h>
#include <linux/netfilter/nf_conntrack_proto_sctp.h>
#include <linux/netfilter/nf_conntrack_proto_dccp.h>",34.63908034573942,15.308067031881908,34.45273614379289,41.17647058823529,47.61904761904761
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_device *al_dev = dev->data;

    if (al_dev == NULL) {
        return -EINVAL;
    }

    if (al_dev->outgoing_cb_list[frame_id] != NULL) {
        return -EBUSY;
    }

    al_dev->outgoing_cb_list[frame_id] = callback;
    al_dev->outgoing_cb_list_size[frame_id] = frame_size;
    al_dev->outgoing_cb_list_user_data[frame_id] = user_data;

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = ""World"";
    char str3[100];

    strcpy(str3, str1);
    strcat(str3, "" "");
    strcat(str3, str2);

    printf(""str1: %s\n"", str1);
    printf(""str2: %s\n"", str2);
    printf(""str3: %s\n"", str3);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = ""World"";
    char str3[100];

    strcpy(str3, str1);
    strcat(str3, "" "");
    strcat(str3, str2);

    printf(""str1: %s\n"", str1);
    printf(""str2: %s\n"", str2);
    printf(""str3: %s\n"", str3);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = ""World"";
    char str3[100];

    strcpy(str3, str1);
    strcat(str3, "" "");
    strcat(str3, str2);

    printf(""str1: %s\n"", str1);
    printf(""str2: %s\n"", str2);
    printf(""str3: %s\n"", str3);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = ""World"";
    char str3[100];

    strcpy(str3, str1);
    strcat(str3, "" "");
    strcat(str3, str2);

    printf(""str1: %s\n"", str1);
    printf(""str2: %s\n"", str2);
    printf(""str3: %s\n"", str3);","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_device *al_dev = dev->data;

    if (al_dev == NULL) {
        return -EINVAL;
    }

    if (al_dev->outgoing_cb_list[frame_id] != NULL) {
        return -EBUSY;
    }

    al_dev->outgoing_cb_list[frame_id] = callback;
    al_dev->outgoing_cb_list_size[frame_id] = frame_size;
    al_dev->outgoing_cb_list_user_data[frame_id] = user_data;

    return 0;
}",36.03715649448592,12.47914238856188,37.34175249694481,51.470588235294116,42.857142857142854
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler,
                                            struct abstract_lin_schedule *schedule) {
  if (scheduler == NULL || schedule == NULL) {
    return -1;
  }

  scheduler->active_schedule = schedule;
  scheduler->current_position = 0;

  return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler,
                                            struct abstract_lin_schedule *schedule) {
  if (scheduler == NULL || schedule == NULL) {
    return -1;
  }

  scheduler->active_schedule = schedule;
  scheduler->current_position = 0;

  return 0;
}",18.546005971214925,0.6926953544217976,4.543960109385256,28.947368421052634,40.0
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    sched->is_running = false;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc(100 * sizeof(char));
    strcpy(str, ""Hello World"");
    printf(""%s\n"", str);
    free(str);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = malloc","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    sched->is_running = false;
}",28.071565660406645,1.1176975325570095,14.501898442402911,30.0,66.66666666666666
