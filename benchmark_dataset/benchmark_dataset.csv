id,repo,commit_hash,filepath,language,code,function_signature,imports,summary_short,summary_long
1,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/datatypes.py,python,"def is_subtype_of(cls, check: str, base: str) -> bool:
    check_type = cls.get_type(check)
    if not check_type:
        raise DatatypesException(f""Not a valid type: '{check}'"")
    base_type = cls.get_type(base)
    if not base_type:
        raise DatatypesException(f""Not a valid type: '{base}'"")
    return check in base_type[2] or check == base","def is_subtype_of(cls, check: str, base: str) -> bool:","from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Set

from vss_tools import log

if TYPE_CHECKING:
    from vss_tools.model import VSSUnit",Checks if a data type is a subtype of a specified base type,"Validates that 'check' and 'base' are known types, then returns true if the 'check' type is identical to the 'base' type or if its name is found within the 'base' type's predefined list of subtypes"
2,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/datatypes.py,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","def is_datatype(cls, value: Any, datatype: str) -> bool:","from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Set

from vss_tools import log

if TYPE_CHECKING:
    from vss_tools.model import VSSUnit",Validates if a value conforms to a datatype specified by a string,"Raises an exception if the specified 'datatype' is unsupported, otherwise retrieves that type's validation function and returns the boolean result of calling it with the provided 'value'"
3,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/datatypes.py,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","def is_xintx(value: Any, signed: bool, bits: int):","from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Set

from vss_tools import log

if TYPE_CHECKING:
    from vss_tools.model import VSSUnit",Checks if a value or list of values is a valid integer for a specified bit-width and signedness.,"Validates that a given value, or each value in a list, is an integer that fits within the numerical range defined by a specified bit-width and signedness"
4,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/datatypes.py,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:","from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Set

from vss_tools import log

if TYPE_CHECKING:
    from vss_tools.model import VSSUnit",Looks up a type definition tuple by its string name from a list of types,"Returns the type definition tuple from a class-level list of types that matches the provided 'datatype' name, or returns None if no match is found"
5,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/datatypes.py,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:","from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Set

from vss_tools import log

if TYPE_CHECKING:
    from vss_tools.model import VSSUnit",Finds all datatypes within the current namespace and any parent namespaces of a given FQN,Returns a dictionary mapping the short name to the full FQN for all dynamic datatypes that exist in the same namespace as the provided FQN
6,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/exporters/samm/helpers/vss_helper.py,python,"def populate_unique_node_names(node_names_dict: dict[str, Any], vss_node: VSSNode) -> None:
    if not node_names_dict.get(vss_node.name):
        node_names_dict.__setitem__(vss_node.name, {""counter"": 1, ""vss_paths"": [vss_node.get_fqn()]})
    else:
        node_names_dict[vss_node.name][""counter""] += 1  # type: ignore
        node_names_dict[vss_node.name][""vss_paths""].append(vss_node.get_fqn())  # type: ignore

    if vss_node.children and len(vss_node.children) > 0:
        for vss_child_node in vss_node.children:
            populate_unique_node_names(node_names_dict, vss_child_node)","def populate_unique_node_names(node_names_dict: dict[str, Any], vss_node: VSSNode) -> None:","import re
from ast import literal_eval
from typing import Any

from rdflib import URIRef
from vss_tools import log
from vss_tools.datatypes import Datatypes
from vss_tools.model import NodeType, VSSDataBranch, VSSDataDatatype
from vss_tools.tree import VSSNode

from ..config import config as cfg
from .data_types_and_units import DataTypes, DataUnits
from .samm_concepts import SammCConcepts, SammConcepts
from .string_helper import str_to_lc_first_camel_case, str_to_uc_first_camel_case",Traverses a VSS tree to count the occurrences and collect the fully qualified paths of each node name,Recursively traverses a VSS node tree to populate a dictionary with the occurrence count and a list of fully qualified paths for each unique node name
7,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/exporters/apigear.py,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type",def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:,"import abc
import typing
from enum import Enum, Flag, auto
from math import inf
from pathlib import Path

import rich_click as click
import yaml

import vss_tools.cli_options as clo
from vss_tools import log
from vss_tools.datatypes import Datatypes
from vss_tools.main import get_trees
from vss_tools.model import VSSDataBranch, VSSDataDatatype, VSSDataStruct
from vss_tools.tree import VSSNode",Converts a string-based data type definition into an ApiGearType object,"Parses a type string to create an `ApiGearType` object, mapping common primitive types to their ApiGear equivalents, sanitizing custom type names by replacing dots with underscores, and setting an array flag based on a ""[]"" suffix"
8,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/exporters/apigear.py,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:","import abc
import typing
from enum import Enum, Flag, auto
from math import inf
from pathlib import Path

import rich_click as click
import yaml

import vss_tools.cli_options as clo
from vss_tools import log
from vss_tools.datatypes import Datatypes
from vss_tools.main import get_trees
from vss_tools.model import VSSDataBranch, VSSDataDatatype, VSSDataStruct
from vss_tools.tree import VSSNode",Generates an ApiGear property from a VSS (Vehicle Signal Specification) node,"Creates an `ApiGearProperty` by converting the VSS node's datatype to a supported ApiGear type and copying its description, returning `None` and logging a warning if the datatype is not supported"
9,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/vspec.py,python,"def get_vspecs(includes: list[Path], spec: Path, prefix: str | None = None) -> list[VSpec]:
    vspecs: list[VSpec] = []
    vspec = VSpec(spec, prefix)
    vspecs.append(vspec)

    for include in vspec.includes:
        include_spec = include.resolve_path(includes + [vspec.source.parent])
        vspecs.extend(get_vspecs(includes, include_spec, include.prefix))

    return vspecs","def get_vspecs(includes: list[Path], spec: Path, prefix: str | None = None) -> list[VSpec]:","from __future__ import annotations

from pathlib import Path
from typing import Any

import yaml

from vss_tools import log",Recursively resolves and flattens a specification file and all its include dependencies,"Recursively parses a given specification file and any files it includes, returning a single, flattened list of all resulting VSpec objects"
10,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/vspec.py,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:","from __future__ import annotations

from pathlib import Path
from typing import Any

import yaml

from vss_tools import log",Loads and merges multiple VSpec files from specified paths into a single VSpec object,"Loads and parses multiple VSpec files from specified paths, using a list of include directories, then merges them into a single composite VSpec object and returns it, raising an exception if no files are successfully loaded"
11,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/vspec.py,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:","from __future__ import annotations

from pathlib import Path
from typing import Any

import yaml

from vss_tools import log","Recursively updates a dictionary with values from another, merging nested dictionaries","Recursively updates a 'base' dictionary with an 'update' dictionary, merging nested dictionaries for common keys and overwriting or adding all other key-value pairs"
12,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/model.py,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:","import re
from enum import Enum
from typing import Any, TypeAlias

import jsonschema
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    ValidationError,
    field_validator,
    model_validator,
)
from rich.pretty import pretty_repr
from typing_extensions import Self

from vss_tools import log
from vss_tools.datatypes import (
    Datatypes,
    DatatypesException,
    dynamic_quantities,
    dynamic_struct_schemas,
    dynamic_units,
    get_all_datatypes,
    is_array,
    resolve_datatype,
)",Validates a constant unique identifier (constUID) is a 32-bit hexadecimal string,"Asserts that the input value, if not None, is a valid 'constUID' formatted as an 8-digit hexadecimal string prefixed with '0x', returning the value if the check passes"
13,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/model.py,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:","import re
from enum import Enum
from typing import Any, TypeAlias

import jsonschema
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    ValidationError,
    field_validator,
    model_validator,
)
from rich.pretty import pretty_repr
from typing_extensions import Self

from vss_tools import log
from vss_tools.datatypes import (
    Datatypes,
    DatatypesException,
    dynamic_quantities,
    dynamic_struct_schemas,
    dynamic_units,
    get_all_datatypes,
    is_array,
    resolve_datatype,
)","Initializes and attempts to resolve a VSS raw model, returning the unresolved model on failure","Initializes a VSSRaw model and attempts to resolve it, returning the successfully resolved model or the original unresolved model if resolution fails due to a validation or model error"
14,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/model.py,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:","import re
from enum import Enum
from typing import Any, TypeAlias

import jsonschema
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    ValidationError,
    field_validator,
    model_validator,
)
from rich.pretty import pretty_repr
from typing_extensions import Self

from vss_tools import log
from vss_tools.datatypes import (
    Datatypes,
    DatatypesException,
    dynamic_quantities,
    dynamic_struct_schemas,
    dynamic_units,
    get_all_datatypes,
    is_array,
    resolve_datatype,
)",Validates that a list of strings are all known datatypes,"Asserts that each string in the input list is a valid datatype by checking against a master list, returning the original list if all values are valid"
15,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/exporters/tree.py,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:","from pathlib import Path

import rich_click as click
from anytree import RenderTree

import vss_tools.cli_options as clo
from vss_tools import log
from vss_tools.main import get_trees
from vss_tools.tree import VSSNode","Renders a VSS tree into a string, displaying specified attributes for each node","Traverses a VSSNode tree to generate a formatted string, displaying each node's name followed by the values of any specified attributes found on it"
16,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/tree.py,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:","from __future__ import annotations

import re
from copy import deepcopy
from typing import Any

from anytree import Node, PreOrderIter, find, findall
from pydantic import ValidationError

from vss_tools import log
from vss_tools.datatypes import Datatypes, dynamic_datatypes, dynamic_struct_schemas, is_array
from vss_tools.model import (
    ModelValidationException,
    VSSData,
    VSSDataBranch,
    VSSDataDatatype,
    VSSDataProperty,
    VSSDataStruct,
    VSSRaw,
    get_vss_raw,
    resolve_vss_raw,
)
from vss_tools.vspec import deep_update",Finds the root of a VSS instance by recursively traversing up the parent hierarchy,"Recursively traverses up the parent hierarchy to find and return the first non-instance ancestor node and the traversal depth, raising an exception if the starting node is not a branch or if no root is found"
17,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/tree.py,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0",def count_instance_children_depth(self) -> int:,"from __future__ import annotations

import re
from copy import deepcopy
from typing import Any

from anytree import Node, PreOrderIter, find, findall
from pydantic import ValidationError

from vss_tools import log
from vss_tools.datatypes import Datatypes, dynamic_datatypes, dynamic_struct_schemas, is_array
from vss_tools.model import (
    ModelValidationException,
    VSSData,
    VSSDataBranch,
    VSSDataDatatype,
    VSSDataProperty,
    VSSDataStruct,
    VSSRaw,
    get_vss_raw,
    resolve_vss_raw,
)
from vss_tools.vspec import deep_update",Counts the depth of a chain of instance branches,Recursively calculates the depth of the first-found branch of children where each node is a `VSSDataBranch` with its `is_instance` flag set
18,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,vss-tools/src/vss_tools/tree.py,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:","from __future__ import annotations

import re
from copy import deepcopy
from typing import Any

from anytree import Node, PreOrderIter, find, findall
from pydantic import ValidationError

from vss_tools import log
from vss_tools.datatypes import Datatypes, dynamic_datatypes, dynamic_struct_schemas, is_array
from vss_tools.model import (
    ModelValidationException,
    VSSData,
    VSSDataBranch,
    VSSDataDatatype,
    VSSDataProperty,
    VSSDataStruct,
    VSSRaw,
    get_vss_raw,
    resolve_vss_raw,
)
from vss_tools.vspec import deep_update",Finds all child node IDs that belong to a specific parent name,Returns a list of node IDs from an input list whose expected parent's name matches the provided `name`
19,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/utils/misc.py,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:","import re
from typing import Any","Gets an attribute, returning a default value if the attribute is missing or its value is None","Retrieves an attribute from an object, returning a specified default value if the attribute is missing or its value is `None`"
20,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/exporters/protobuf.py,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):","import sys
from io import TextIOWrapper
from pathlib import Path

import rich_click as click
from anytree import findall

import vss_tools.cli_options as clo
from vss_tools import log
from vss_tools.main import get_trees
from vss_tools.model import (
    VSSDataBranch,
    VSSDataDatatype,
    VSSDataStruct,
)
from vss_tools.tree import VSSNode",Generates a Protobuf schema from a Vehicle Signal Specification (VSS) tree,Generates a `proto3` file from a VSS tree by first writing import statements for complex data types and then converting each branch in the tree into a corresponding protobuf message
21,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/exporters/utils.py,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:","from anytree import PreOrderIter

from vss_tools.model import VSSDataBranch, VSSDataDatatype
from vss_tools.tree import VSSNode",Groups all leaf VSS branch instances by the fully qualified name of their original branch definition,"Traverses a VSS tree to find all terminal instance branches, grouping their relative names into a dictionary where each key is the fully qualified name of the original branch they instantiate"
22,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/exporters/utils.py,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False",def is_VSS_leaf(node: VSSNode) -> bool:,"from anytree import PreOrderIter

from vss_tools.model import VSSDataBranch, VSSDataDatatype
from vss_tools.tree import VSSNode",Determines if a VSS node is a leaf based on its data type,Checks if a given VSSNode is a leaf by verifying its 'data' attribute is an instance of VSSDataDatatype
23,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/exporters/utils.py,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False",def is_VSS_branch(node: VSSNode) -> bool:,"from anytree import PreOrderIter

from vss_tools.model import VSSDataBranch, VSSDataDatatype
from vss_tools.tree import VSSNode",Checks if a VSS node is a branch that is not an instance,Returns `True` if the given `VSSNode`'s data is a `VSSDataBranch` and its `is_instance` attribute is `False`
24,https://github.com/COVESA/vss-tools,8a8e64de6b1ecdb831e880e105f0644e81af782f,src/vss_tools/exporters/utils.py,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False",def is_VSS_branch_instance(node: VSSNode) -> bool:,"from anytree import PreOrderIter

from vss_tools.model import VSSDataBranch, VSSDataDatatype
from vss_tools.tree import VSSNode",Checks if a VSS node represents a branch instance,Returns True if the node's data is a VSSDataBranch and its 'is_instance' attribute is True
25,https://github.com/COVESA/vss-tools,f0f5822d047cb62df488f132160deacdf96ddc63,src/vss_tools/utils/idgen_utils.py,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash",def fnv1_32_hash(identifier: bytes) -> int:,No imports,FNV-1 32-bit hashing algorithm for a byte sequence,"Calculates a 32-bit FNV-1 hash for a given byte string by iterating through each byte, multiplying the current hash by the FNV prime, and then performing a bitwise XOR with the byte"
26,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioCard.java,java,"public CardPresenter getCardPresenter() {
    if (mAudioCardPresenter == null) {
        mAudioCardPresenter = new HomeAudioCardPresenter();
        if (mViewModelProvider == null) {
            Log.w(TAG, ""No ViewModelProvider set. Cannot get MediaViewModel"");
            mAudioCardPresenter.setModels(
                    Collections.unmodifiableList(Collections.singletonList(
                            new InCallModel(SystemClock.elapsedRealtimeClock()))));
        } else {
            mAudioCardPresenter.setModels(Collections.unmodifiableList(Arrays.asList(
                    mViewModelProvider.get(MediaViewModel.class),
                    new InCallModel(SystemClock.elapsedRealtimeClock()))));
        }
    }
    return mAudioCardPresenter;
}",public CardPresenter getCardPresenter() {,"import android.os.SystemClock;
import android.util.Log;

import androidx.lifecycle.ViewModelProvider;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.CardPresenter;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardModule;

import java.util.Arrays;
import java.util.Collections;",Lazily initializes and returns an audio card presenter with data models for media and in-call status,"Lazily initializes and returns a `HomeAudioCardPresenter`, setting its data models with both a `MediaViewModel` and an `InCallModel` if a `ViewModelProvider` is available, otherwise logging a warning and using only the `InCallModel`"
27,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioCard.java,java,"public HomeCardFragment getCardView() {
    if (mAudioCardView == null) {
        mAudioCardView = new AudioFragment();
        getCardPresenter().setView(mAudioCardView);
        mAudioCardView.setPresenter(getCardPresenter());
    }
    return mAudioCardView;
}",public HomeCardFragment getCardView() {,"import android.os.SystemClock;
import android.util.Log;

import androidx.lifecycle.ViewModelProvider;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.CardPresenter;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardModule;

import java.util.Arrays;
import java.util.Collections;",Lazily initializes and returns the audio card view fragment,"Lazily initializes and returns an `AudioFragment`, bidirectionally linking it with its presenter upon first creation"
28,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/HomeCardFragment.java,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {","
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.fragment.app.Fragment;

import com.android.car.apps.common.CrossfadeImageView;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextView;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.carlauncher.homescreen.ui.TextBlockView;",Inflates a card fragment's layout and initializes its view components,"Inflates the `card_fragment` layout, finds and assigns the card's title and icon views, and returns the resulting root view"
29,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/HomeCardFragment.java,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {","import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.fragment.app.Fragment;

import com.android.car.apps.common.CrossfadeImageView;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextView;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.carlauncher.homescreen.ui.TextBlockView;","Sets a button's icon and click listener to make it visible, or hides it if no content is provided","Updates an `ImageButton`'s icon and click listener from a content object and makes it visible, or hides the button if the content is null"
30,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/HomeCardFragment.java,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}",protected final View getDescriptiveTextOnlyLayoutView() {,"import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.fragment.app.Fragment;

import com.android.car.apps.common.CrossfadeImageView;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextView;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.carlauncher.homescreen.ui.TextBlockView;",Lazily inflates and initializes a descriptive text layout view on first access,"Lazily inflates a `ViewStub` to create a descriptive text layout, caches references to its child views (title, subtitle, image), and returns the inflated layout"
31,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/HomeCardFragment.java,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}",public void updateHeaderView(CardHeader header) {,"import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.fragment.app.Fragment;

import com.android.car.apps.common.CrossfadeImageView;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextView;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.carlauncher.homescreen.ui.TextBlockView;",Updates and displays a card header view with a new title and icon,Updates the header view on the main UI thread by making its root view visible and setting the card's title and icon from the provided `CardHeader` object
32,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/homescreen/HomeCardFragment.java,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}",private View getTextBlockLayoutView() {,"import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.fragment.app.Fragment;

import com.android.car.apps.common.CrossfadeImageView;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextView;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.carlauncher.homescreen.ui.TextBlockView;",Lazily inflates and returns a text block layout view from a ViewStub,"Lazily inflates a `ViewStub` to create and return the text block layout view, while also finding and caching references to its child text views on the first call"
33,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/AppLauncherUtils.java,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {","import static java.lang.annotation.RetentionPolicy.SOURCE;

import android.annotation.Nullable;
import android.app.Activity;
import android.app.ActivityOptions;
import android.car.Car;
import android.car.CarNotConnectedException;
import android.car.content.pm.CarPackageManager;
import android.car.media.CarMediaManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LauncherActivityInfo;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Process;
import android.service.media.MediaBrowserService;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.IntDef;
import androidx.annotation.NonNull;

import java.lang.annotation.Retention;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;",Gets the media browser service component from a given package,"Queries the `PackageManager` for a `MediaBrowserService` within a given package and returns a `ComponentName` for the first one found, or `null` if none exist"
34,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/AppLauncherUtils.java,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {","import static java.lang.annotation.RetentionPolicy.SOURCE;

import android.annotation.Nullable;
import android.app.Activity;
import android.app.ActivityOptions;
import android.car.Car;
import android.car.CarNotConnectedException;
import android.car.content.pm.CarPackageManager;
import android.car.media.CarMediaManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LauncherActivityInfo;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Process;
import android.service.media.MediaBrowserService;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.IntDef;
import androidx.annotation.NonNull;

import java.lang.annotation.Retention;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;",Determines if an app component should be launchable by filtering against a hide list and de-duplicating media services,"Determines if a component should be added to a launchable list, returning `false` if its package is explicitly hidden or if it's a custom media component and launchable apps are also being shown, otherwise returning `true` for valid launchable or media service types"
35,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/AppLauncherUtils.java,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {","import static java.lang.annotation.RetentionPolicy.SOURCE;

import android.annotation.Nullable;
import android.app.Activity;
import android.app.ActivityOptions;
import android.car.Car;
import android.car.CarNotConnectedException;
import android.car.content.pm.CarPackageManager;
import android.car.media.CarMediaManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LauncherActivityInfo;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Process;
import android.service.media.MediaBrowserService;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.IntDef;
import androidx.annotation.NonNull;

import java.lang.annotation.Retention;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;",Sets the media source and finishes the current activity,"Sets the car's media source to a given component in browse mode and finishes the context if it's an Activity, catching and logging a `CarNotConnectedException` if the car service is unavailable"
36,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/AppLauncherUtils.java,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {","import static java.lang.annotation.RetentionPolicy.SOURCE;

import android.annotation.Nullable;
import android.app.Activity;
import android.app.ActivityOptions;
import android.car.Car;
import android.car.CarNotConnectedException;
import android.car.content.pm.CarPackageManager;
import android.car.media.CarMediaManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LauncherActivityInfo;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Process;
import android.service.media.MediaBrowserService;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.IntDef;
import androidx.annotation.NonNull;

import java.lang.annotation.Retention;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;","Safely checks if a given activity is distraction-optimized, handling potential connection errors","Safely checks if a given activity is distraction optimized using the `CarPackageManager`, returning `false` and logging an error if the manager is null or a `CarNotConnectedException` is caught"
37,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/CarLauncher.java,java,"private void setUpTaskView(ViewGroup parent) {
    mTaskViewManager = new TaskViewManager(this,
            new HandlerExecutor(getMainThreadHandler()));
    mTaskViewManager.createTaskView(taskView -> {
        taskView.setListener(getMainExecutor(), mTaskViewListener);
        parent.addView(taskView);
        mTaskView = taskView;
    });
}",private void setUpTaskView(ViewGroup parent) {,"import static android.app.ActivityTaskManager.INVALID_TASK_ID;
import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_TRUSTED_OVERLAY;

import android.app.ActivityOptions;
import android.app.ActivityTaskManager;
import android.app.PendingIntent;
import android.app.TaskStackListener;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Bundle;
import android.util.Log;
import android.view.Display;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.collection.ArraySet;
import androidx.fragment.app.FragmentActivity;
import androidx.fragment.app.FragmentTransaction;
import androidx.lifecycle.ViewModelProvider;

import com.android.car.carlauncher.homescreen.HomeCardModule;
import com.android.car.internal.common.UserHelperLite;
import com.android.wm.shell.TaskView;
import com.android.wm.shell.common.HandlerExecutor;

import java.net.URISyntaxException;
import java.util.Set;","Asynchronously creates, configures, and adds a task view to a parent view group","Initializes a `TaskViewManager` to asynchronously create a `TaskView`, which upon creation is configured with a listener, added to the parent `ViewGroup`, and stored as a member variable"
38,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/CarLauncher.java,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}",private Intent getMapsIntent() {,"import static android.app.ActivityTaskManager.INVALID_TASK_ID;
import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_TRUSTED_OVERLAY;

import android.app.ActivityOptions;
import android.app.ActivityTaskManager;
import android.app.PendingIntent;
import android.app.TaskStackListener;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Bundle;
import android.util.Log;
import android.view.Display;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.collection.ArraySet;
import androidx.fragment.app.FragmentActivity;
import androidx.fragment.app.FragmentTransaction;
import androidx.lifecycle.ViewModelProvider;

import com.android.car.carlauncher.homescreen.HomeCardModule;
import com.android.car.internal.common.UserHelperLite;
import com.android.wm.shell.TaskView;
import com.android.wm.shell.common.HandlerExecutor;

import java.net.URISyntaxException;
import java.util.Set;","Retrieves a specific, configured Intent for the default maps app, falling back to a generic one","Retrieves a specific, resolvable map `Intent` from a configured list if it matches the system's default map app, otherwise falls back to a generic `Intent` for any map application"
39,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,aosp_device_covesa_emulator/CustomCarLauncher/src/com/android/car/carlauncher/CarLauncher.java,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}",private void initializeCards() {,"import static android.app.ActivityTaskManager.INVALID_TASK_ID;
import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_TRUSTED_OVERLAY;

import android.app.ActivityOptions;
import android.app.ActivityTaskManager;
import android.app.PendingIntent;
import android.app.TaskStackListener;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Bundle;
import android.util.Log;
import android.view.Display;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.collection.ArraySet;
import androidx.fragment.app.FragmentActivity;
import androidx.fragment.app.FragmentTransaction;
import androidx.lifecycle.ViewModelProvider;

import com.android.car.carlauncher.homescreen.HomeCardModule;
import com.android.car.internal.common.UserHelperLite;
import com.android.wm.shell.TaskView;
import com.android.wm.shell.common.HandlerExecutor;

import java.net.URISyntaxException;
import java.util.Set;",Dynamically instantiates and displays home card modules defined in a configuration resource,"Lazily initializes a set of `HomeCardModule`s by reflectively instantiating class names from a configuration array, and then uses a `FragmentTransaction` to add each module's card view to the UI layout"
40,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/TaskViewManager.java,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}",private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {,"import static android.app.WindowConfiguration.WINDOWING_MODE_MULTI_WINDOW;

import static com.android.car.carlauncher.CarLauncher.TAG;
import static com.android.wm.shell.ShellTaskOrganizer.TASK_LISTENER_TYPE_FULLSCREEN;

import android.annotation.UiContext;
import android.app.ActivityTaskManager;
import android.app.TaskInfo;
import android.content.Context;
import android.util.Slog;
import android.window.TaskAppearedInfo;

import com.android.wm.shell.FullscreenTaskListener;
import com.android.wm.shell.ShellTaskOrganizer;
import com.android.wm.shell.TaskView;
import com.android.wm.shell.TaskViewFactory;
import com.android.wm.shell.TaskViewFactoryController;
import com.android.wm.shell.common.HandlerExecutor;
import com.android.wm.shell.common.SyncTransactionQueue;
import com.android.wm.shell.common.TransactionPool;
import com.android.wm.shell.startingsurface.StartingWindowController;
import com.android.wm.shell.startingsurface.phone.PhoneStartingWindowTypeAlgorithm;

import java.util.List;
import java.util.function.Consumer;",Removes dangling tasks that are in multi-window mode,"Iterates through a list of appeared tasks and uses the `ActivityTaskManager` to remove any task that is in multi-window mode, logging it as a dangling task"
41,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/AppGridActivity.java,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}",private void updateMode() {,"import static com.android.car.carlauncher.AppLauncherUtils.APP_TYPE_LAUNCHABLES;
import static com.android.car.carlauncher.AppLauncherUtils.APP_TYPE_MEDIA_SERVICES;

import android.app.Activity;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.car.Car;
import android.car.CarNotConnectedException;
import android.car.content.pm.CarPackageManager;
import android.car.drivingstate.CarUxRestrictionsManager;
import android.car.media.CarMediaManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.StringRes;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.GridLayoutManager.SpanSizeLookup;
import androidx.recyclerview.widget.RecyclerView;

import com.android.car.carlauncher.AppLauncherUtils.LauncherAppsInfo;
import com.android.car.ui.FocusArea;
import com.android.car.ui.baselayout.Insets;
import com.android.car.ui.baselayout.InsetsChangedListener;
import com.android.car.ui.core.CarUi;
import com.android.car.ui.toolbar.MenuItem;
import com.android.car.ui.toolbar.Toolbar;
import com.android.car.ui.toolbar.ToolbarController;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;",Updates the mode from the intent and sets the UI title accordingly,Parses the mode from the current Intent and sets the title for both the Activity and the CarUi toolbar using the string resource ID defined in that mode
42,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioFragment.java,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}",private Chronometer getChronometer() {,"import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.View;
import android.view.ViewStub;
import android.widget.Chronometer;
import android.widget.TextView;

import com.android.car.apps.common.BitmapUtils;
import com.android.car.apps.common.ImageUtils;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;",Lazily initializes and returns the Chronometer view on first access,"Lazily initializes and returns a `Chronometer` by finding it in the layout, while also finding and caching its associated separator view on the first call"
43,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioFragment.java,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}",private View getMediaLayoutView() {,"import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.View;
import android.view.ViewStub;
import android.widget.Chronometer;
import android.widget.TextView;

import com.android.car.apps.common.BitmapUtils;
import com.android.car.apps.common.ImageUtils;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;",Blurs and scales an image to set as a card's visible background,"Lazily inflates a media layout from a `ViewStub`, finds and caches its title and subtitle views, initializes its media playback controls bar via a presenter, and returns the inflated view"
44,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioFragment.java,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}",private void updateBackgroundImage(Drawable image) {,"import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.View;
import android.view.ViewStub;
import android.widget.Chronometer;
import android.widget.TextView;

import com.android.car.apps.common.BitmapUtils;
import com.android.car.apps.common.ImageUtils;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;",Blurs and scales an image to set as a card's visible background,"If a valid `Drawable` and card size are provided, this method scales the image to a square based on the card's largest dimension, blurs it, and sets the resulting bitmap as the animated, visible card background"
45,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioFragment.java,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {","import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.View;
import android.view.ViewStub;
import android.widget.Chronometer;
import android.widget.TextView;

import com.android.car.apps.common.BitmapUtils;
import com.android.car.apps.common.ImageUtils;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;",Makes the media view visible and sets its title and subtitle,Makes the media layout view visible and updates its title and subtitle with the provided text
46,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/AudioFragment.java,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}",private void updateAudioDuration(DescriptiveTextWithControlsView content) {,"import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Size;
import android.view.View;
import android.view.ViewStub;
import android.widget.Chronometer;
import android.widget.TextView;

import com.android.car.apps.common.BitmapUtils;
import com.android.car.apps.common.ImageUtils;
import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardFragment;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;","Starts and shows a chronometer if a start time is positive; otherwise, hides it","If the content's start time is positive, this method makes a chronometer and a separator visible, sets the chronometer's base time, and starts it; otherwise, it hides both views"
47,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/InCallModel.java,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}",public void onCallAdded(Call call) {,"import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.os.IBinder;
import android.telecom.Call;
import android.telecom.TelecomManager;
import android.util.Log;
import android.view.View;

import androidx.core.content.ContextCompat;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.audio.telecom.InCallServiceImpl;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.telephony.common.CallDetail;
import com.android.car.telephony.common.TelecomUtils;
import com.android.internal.annotations.VisibleForTesting;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.time.Clock;
import java.util.concurrent.CompletableFuture;",Registers a callback on a newly added call,Registers a member callback to the provided `Call` object after verifying it is not null
48,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/InCallModel.java,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}",public void onCallRemoved(Call call) {,"import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.os.IBinder;
import android.telecom.Call;
import android.telecom.TelecomManager;
import android.util.Log;
import android.view.View;

import androidx.core.content.ContextCompat;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.audio.telecom.InCallServiceImpl;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.telephony.common.CallDetail;
import com.android.car.telephony.common.TelecomUtils;
import com.android.internal.annotations.VisibleForTesting;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.time.Clock;
import java.util.concurrent.CompletableFuture;",Resets state and unregisters the callback when a call is removed,"Handles the removal of a call by clearing the current call and card content, notifying the presenter of the model update, and unregistering its callback from the call object for cleanup"
49,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/InCallModel.java,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}",void updateModelWithPhoneNumber(String number) {,"import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.os.IBinder;
import android.telecom.Call;
import android.telecom.TelecomManager;
import android.util.Log;
import android.view.View;

import androidx.core.content.ContextCompat;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.audio.telecom.InCallServiceImpl;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.telephony.common.CallDetail;
import com.android.car.telephony.common.TelecomUtils;
import com.android.internal.annotations.VisibleForTesting;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.time.Clock;
import java.util.concurrent.CompletableFuture;",Updates the ongoing call view model with a formatted phone number and UI controls,"Formats a phone number to create a new `DescriptiveTextWithControlsView` with call details and controls, then notifies the presenter that the model has been updated"
50,https://github.com/COVESA/aosp_device_covesa_emulator,063f1782fab8dcb427cf7de31d6c00bcb9b6cb4e,CustomCarLauncher/src/com/android/car/carlauncher/homescreen/audio/InCallModel.java,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}",private void initializeAudioControls() {,"import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.os.IBinder;
import android.telecom.Call;
import android.telecom.TelecomManager;
import android.util.Log;
import android.view.View;

import androidx.core.content.ContextCompat;

import com.android.car.carlauncher.R;
import com.android.car.carlauncher.homescreen.HomeCardInterface;
import com.android.car.carlauncher.homescreen.audio.telecom.InCallServiceImpl;
import com.android.car.carlauncher.homescreen.ui.CardContent;
import com.android.car.carlauncher.homescreen.ui.CardHeader;
import com.android.car.carlauncher.homescreen.ui.DescriptiveTextWithControlsView;
import com.android.car.telephony.common.CallDetail;
import com.android.car.telephony.common.TelecomUtils;
import com.android.internal.annotations.VisibleForTesting;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.time.Clock;
import java.util.concurrent.CompletableFuture;","Initializes the Mute, End Call, and Dialpad buttons for an in-call user interface","Initializes mute, end call, and dialpad buttons by assigning each an icon and a click listener to toggle mute status, disconnect the current call, and delegate to an onClick handler, respectively"
51,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"bool DBusConnection::sendDBusMessage(const DBusMessage &_message) const {
    if (!_message) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return false;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return false;
    }

    dbus_uint32_t dbusSerial;
    const bool result = (0 != dbus_connection_send(connection_, _message.message_, &dbusSerial));
    return result;
}",bool DBusConnection::sendDBusMessage(const DBusMessage &_message) const {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Sends a D-Bus message over the connection and returns a boolean indicating success,"Sends a given `DBusMessage` over an established D-Bus connection, returning `true` on success and `false` if the message is invalid, the connection is down, or the underlying send operation fails"
52,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusClientId.cpp,cpp,"DBusMessage DBusClientId::createMessage(const std::string objectPath, const std::string interfaceName, const std::string signalName) const
{
    DBusMessage returnMessage = DBusMessage::createSignal(objectPath, interfaceName, signalName);
    returnMessage.setDestination(dbusId_.c_str());

    return (returnMessage);
}","DBusMessage DBusClientId::createMessage(const std::string objectPath, const std::string interfaceName, const std::string signalName) const {","#include <typeinfo>

#include <CommonAPI/DBus/DBusClientId.hpp>
#include <CommonAPI/DBus/DBusMessage.hpp>",Creates a D-Bus signal message addressed to a specific client,"Creates and returns a D-Bus signal message, constructed from the provided object path, interface, and signal name, with its destination set to the current client's D-Bus ID"
53,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {","#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Notifies a newly added listener if the D-Bus connection is already available,"When a new listener is added, this callback immediately notifies it with an `AVAILABLE` status if the D-Bus connection is already active"
54,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {","#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>","For an active connection, adds a thread to a list to be joined on exit, avoiding duplicates","Atomically registers a given thread to be joined later by adding it to a list, but only if its associated connection is active and the thread is not already present in the list"
55,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnection::onWakeupMainContext(void* data) {
    std::weak_ptr<MainLoopContext>* mainloop = static_cast<std::weak_ptr<MainLoopContext>*>(data);

    if (!mainloop) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""mainloop == nullptr"");
    } else if(auto lockedContext = mainloop->lock()) {
        lockedContext->wakeup();
    }
}",void DBusConnection::onWakeupMainContext(void* data) {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",A callback that wakes up a main loop context if it has not been destroyed,Wakes up a `MainLoopContext` by locking a `weak_ptr` (passed via a `void*` pointer) to ensure the context object still exists before calling its `wakeup()` method
56,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {","#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",A callback to stop monitoring a D-Bus watch and clean up its associated data,A callback function that handles the removal of a D-Bus watch by stopping its monitoring and disassociating the high-level wrapper object from the underlying `libdbus` watch
57,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {","#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>","A libdbus callback that creates, starts, or stops a D-Bus watch based on its readiness status","Handles the toggling of a D-Bus watch by creating a C++ wrapper object for it on first use, and then starting or stopping its monitoring based on its readiness status"
58,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}",const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Thread-safely gets or creates a singleton DBusObjectManager instance using double-checked locking,"Lazily initializes and returns a thread-safe, singleton `DBusObjectManager` instance using a double-checked locking pattern"
59,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}",bool DBusConnection::releaseServiceName(const std::string& serviceName) const {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Performs a reference-counted release of a D-Bus service name,"Decrements a reference count for a given D-Bus service name, releasing it from the bus if the count reaches zero, and returns `true` on success or `false` if the name was not being tracked"
60,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}",DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Steals the reply from a pending D-Bus call and wraps it in a DBusMessage object,"Steals the reply from a `DBusPendingCall` handle and wraps it in a new `DBusMessage` object that takes ownership, returning an empty message if the input handle is null"
61,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}",void DBusConnection::deleteAsyncHandlers() {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Safely deletes all pending asynchronous handlers from a shared list,Thread-safely deallocates a collection of asynchronous D-Bus message reply handlers by moving them from a protected member list to a local copy before iterating through and deleting each one
62,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusConnection.cpp,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}",void DBusConnection::handleSignalStates() {,"#include <algorithm>
#include <chrono>
#include <future>
#include <sstream>
#include <thread>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInputStream.hpp>
#include <CommonAPI/DBus/DBusMainLoop.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Reports a success status to all registered signal handlers for their associated tags,Thread-safely notifies all registered signal handlers of a successful state by invoking their `onSpecificError` callback with a `SUCCESS` status for each associated signal tag
63,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusFactory.cpp,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}",void Factory::releaseConnection(const ConnectionId_t& _connectionId) {,"#include <iostream>
#include <sstream>

#include <CommonAPI/Logger.hpp>
#include <CommonAPI/Runtime.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusStubAdapter.hpp>",Thread-safely removes a connection from a collection if it exists,"Thread-safely removes a connection, identified by its ID, from an internal collection if it exists"
64,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.cpp,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}",void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {,"#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>

#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Dispatches D-Bus signals for interface addition or removal to specific handlers,"Handles an incoming D-Bus signal by dispatching it to the appropriate handler for either ""InterfacesAdded"" or ""InterfacesRemoved"" events based on the message's member name"
65,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.cpp,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {","#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>

#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Retrieves the addresses of available service instances from a D-Bus registry,"Retrieves available service instances from a registry, translates the internal D-Bus representation into a vector of `DBusAddress` objects, and populates the provided output vector and status parameter"
66,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.cpp,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {","#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>

#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Queries a D-Bus registry to determine if a specific service instance is available,"Gets the availability status of a service instance by translating its identifier to a D-Bus address and querying a registry, setting the result and a success status in output parameters"
67,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.cpp,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}",void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {,"#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>

#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Notifies that a service is unavailable when its corresponding D-Bus interface is removed,"Handles a D-Bus ""InterfacesRemoved"" signal by parsing the object path and interface names, and for any interface matching the one being observed, notifies listeners that its status has changed to ""NOT_AVAILABLE"""
68,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.cpp,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {","#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>

#include <CommonAPI/DBus/DBusAddressTranslator.hpp>",Notifies CommonAPI listeners of a D-Bus interface's availability status change,Notifies listeners of an interface's availability change by translating its D-Bus path and name into a generic CommonAPI address
69,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusProxy.cpp,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {","#include <sstream>

#include <CommonAPI/Utils.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusUtils.hpp>
#include <CommonAPI/DBus/DBusProxyAsyncSignalMemberCallbackHandler.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/Logger.hpp>",Schedules an asynchronous notification of the current proxy status for a newly added listener,"Thread-safely schedules a task on the main event loop to notify a newly added listener, passing along its specific subscription details"
70,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusProxy.cpp,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {","#include <sstream>

#include <CommonAPI/Utils.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusUtils.hpp>
#include <CommonAPI/DBus/DBusProxyAsyncSignalMemberCallbackHandler.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/Logger.hpp>",Removes all listener entries that match a given subscription in a thread-safe manner,Thread-safely removes all listeners from an internal collection that match the provided `Subscription` identifier
71,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusProxyBase.cpp,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {","#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusProxyBase.hpp>
#include <CommonAPI/DBus/DBusMessage.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusDaemonProxy.hpp>",Forwards the addition of a D-Bus signal state handler to the underlying connection object,Delegates the registration of a signal state handler for a specific subscription to the underlying connection object
72,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusProxyManager.cpp,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {","#include <CommonAPI/Runtime.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusProxyManager.hpp>",Callback to translate available D-Bus service instance addresses to strings and forward the result,Handles the result of an asynchronous service instance query by translating the `DBusAddress` list to a string list on success and invoking a final callback with the call status and the translated list
73,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusObjectManager.cpp,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}",bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {,"#include <sstream>
#include <unordered_set>
#include <algorithm>

#include <dbus/dbus-protocol.h>

#include <CommonAPI/Utils.hpp>
#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusDaemonProxy.hpp>
#include <CommonAPI/DBus/DBusFreedesktopPropertiesStub.hpp>
#include <CommonAPI/DBus/DBusObjectManager.hpp>
#include <CommonAPI/DBus/DBusOutputStream.hpp>
#include <CommonAPI/DBus/DBusStubAdapter.hpp>
#include <CommonAPI/DBus/DBusUtils.hpp>",Routes a D-Bus message to a registered handler or handles standard introspection requests,"Dispatches an incoming `DBusMessage` to a registered handler based on its object path and interface, or handles it as a standard introspection request, returning `true` if the message was processed"
74,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusObjectManager.cpp,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {","#include <sstream>
#include <unordered_set>
#include <algorithm>

#include <dbus/dbus-protocol.h>

#include <CommonAPI/Utils.hpp>
#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusDaemonProxy.hpp>
#include <CommonAPI/DBus/DBusFreedesktopPropertiesStub.hpp>
#include <CommonAPI/DBus/DBusObjectManager.hpp>
#include <CommonAPI/DBus/DBusOutputStream.hpp>
#include <CommonAPI/DBus/DBusStubAdapter.hpp>
#include <CommonAPI/DBus/DBusUtils.hpp>","Adds a D-Bus interface handler to a path, preventing duplicate registration except for standard interfaces","Registers a D-Bus interface handler for a specific path, returning `false` if the exact handler is already registered, but allowing idempotent registration for standard `ObjectManager` and `Properties` interfaces"
75,https://github.com/COVESA/capicxx-dbus-runtime,eacbbde07cb0f944cabdfcb5bd50ac637ea94e1a,src/CommonAPI/DBus/DBusObjectManager.cpp,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {","#include <sstream>
#include <unordered_set>
#include <algorithm>

#include <dbus/dbus-protocol.h>

#include <CommonAPI/Utils.hpp>
#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusDaemonProxy.hpp>
#include <CommonAPI/DBus/DBusFreedesktopPropertiesStub.hpp>
#include <CommonAPI/DBus/DBusObjectManager.hpp>
#include <CommonAPI/DBus/DBusOutputStream.hpp>
#include <CommonAPI/DBus/DBusStubAdapter.hpp>
#include <CommonAPI/DBus/DBusUtils.hpp>","Registers a D-Bus handler for a specific path, preventing duplicates","Registers a given `DBusInterfaceHandler` to a specific path in a table, returning `true` on success and `false` if the handler is already registered for that path"
76,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"void send_negative_response(enum UDS_SID request_sid,
                            enum UDS_NRC response_code) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_NEGATIVE_RESPONSE, request_sid, response_code};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_negative_response(enum UDS_SID request_sid, enum UDS_NRC response_code) {","#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a UDS negative response message containing the failed service ID and a negative response code,"Constructs and sends a 3-byte UDS negative response message (containing the original request SID and a negative response code) over a CAN bus using the ISO-TP protocol, logging an error if the transmission fails"
77,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"static void send_session_control_response(enum UdsSessionState session_type,
                                          uint16_t p2_timeout_ms,
                                          uint16_t p2_star_timeout_ms) {
  int ret;
  uint8_t positive_sid = UDS_SID_DIAGNOSTIC_SESSION_CONTROL + 0x40;

  uint8_t tx_data[] = {
    positive_sid,
    session_type,
    (p2_timeout_ms >> 8) & 0xFF,
    p2_timeout_ms & 0xFF,
    ((p2_star_timeout_ms / 10) >> 8) & 0xFF,
    (p2_star_timeout_ms / 10) & 0xFF,
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_session_control_response(enum UdsSessionState session_type, uint16_t p2_timeout_ms, uint16_t p2_star_timeout_ms) {","#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a UDS positive response for the Diagnostic Session Control service,"Constructs and sends a 6-byte UDS positive response for a Diagnostic Session Control requestcontaining the session type, P2, and P2* server timeout valuesover a CAN bus via the ISO-TP protocol, logging an error if the transmission fails"
78,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",void send_positive_reset_response(uint8_t reset_type) {,"#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a positive UDS response for the ECU Reset service,"Constructs and sends a 2-byte UDS positive response to an ECU Reset request, containing the positive response SID and the echoed reset type, over a CAN bus using the ISO-TP protocol, logging an error if the transmission fails"
79,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {","#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>","Handles a UDS ECU Reset request, supporting only the hard reset sub-function which reboots the system","Processes a UDS ECU Reset request, validating the 2-byte message length, sending a positive response before triggering a system reboot for a 'hard reset', and sending a negative response for either an incorrect length or an unsupported reset sub-function"
80,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",void send_request_download_response() {,"#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>","Sends a positive UDS response to a Request Download, specifying the maximum block length","Constructs and sends a 4-byte UDS positive response for a ""Request Download"" service, specifying a maximum block length of 0x00D2, over a CAN bus using the ISO-TP protocol and logging an error on failure"
81,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",static void send_transfer_data_response(uint8_t block_sequence_counter) {,"#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a UDS Transfer Data positive response containing the block sequence counter,"Constructs and sends a 2-byte UDS positive response for a Transfer Data request (containing the positive SID and the block sequence counter) over a CAN bus using the ISO-TP protocol, logging an error if the transmission fails"
82,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {","#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a UDS positive response for the Routine Control service containing a result code over ISO-TP,"Constructs and sends a 5-byte UDS positive response for the Routine Control service (containing the routine control type, routine ID, and a result code) over a CAN bus via ISO-TP, logging an error if the transmission fails"
83,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/uds/uds.c,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",static void send_transer_exit_positive_response() {,"#include <zephyr/canbus/isotp.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include ""uds.h""
#include ""uds_session.h""

#include <zephyr/dfu/flash_img.h>
#include <zephyr/dfu/mcuboot.h>
#include <zephyr/storage/flash_map.h>
#include <zephyr/sys/reboot.h>",Sends a UDS Transfer Exit positive response message via the ISO-TP protocol,"Constructs and sends a 1-byte UDS positive response for a Transfer Exit request (containing the request SID + 0x40) over a CAN bus using the ISO-TP protocol, logging an error if the transmission fails"
84,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/hv_shield/dac/hv_shield_dac.c,c,"static int hvs_dac_convert_gain(int raw_gain,
                                enum hv_shield_dac_gains_t* gain) {
  switch (raw_gain) {
    case 1:
      *gain = HV_SHIELD_DAC_GAIN_1;
      return 0;
    case 2:
      *gain = HV_SHIELD_DAC_GAIN_2;
      return 0;
    case 4:
      *gain = HV_SHIELD_DAC_GAIN_4;
      return 0;
    case 8:
      *gain = HV_SHIELD_DAC_GAIN_8;
      return 0;
    case 16:
      *gain = HV_SHIELD_DAC_GAIN_16;
      return 0;
    default:
      return -ENOTSUP;
  }
}","static int hvs_dac_convert_gain(int raw_gain, enum hv_shield_dac_gains_t* gain) {","#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/dac.h>
#include <zephyr/logging/log.h>","Converts a raw integer gain value to a corresponding DAC gain enumeration, returning an error if unsupported","Maps a raw integer gain value (1, 2, 4, 8, or 16) to its corresponding `hv_shield_dac_gains_t` enum representation, returning 0 on success or an `-ENOTSUP` error code for any unsupported input"
85,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/can/lin2can/lin2can.c,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}",static inline uint8_t map_from_can_id(uint32_t can_id) {,"#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>",Finds the index of a given CAN ID in a mapping table,"Searches a predefined `id_mapping` array for a given CAN ID and returns its corresponding index, or `0xff` if the ID is not found"
86,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/can/lin2can/lin2can.c,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {","#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>","Removes a specific LIN-to-CAN receive filter, or all filters, by clearing the associated callback","Disables a specific LIN-to-CAN receive filter by clearing its callback pointer, or disables all filters if a special ID is passed, while ignoring out-of-bounds IDs"
87,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/can/lin2can/lin2can.c,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {","#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>",A LIN callback that dequeues a frame for transmission and executes its completion callback,"A LIN driver callback that retrieves a pending outgoing frame from a message queue, copies its data for transmission, invokes a frame-specific completion callback, and returns a boolean indicating if a frame was successfully prepared"
88,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/can/lin2can/lin2can.c,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {","#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>",A callback that translates an incoming LIN frame to a CAN frame and invokes a registered handler,"Acts as a LIN-to-CAN gateway callback, translating an incoming LIN frame by using its first data byte's top two bits as an index to find a target CAN ID, constructing a new CAN frame with the translated ID and a payload where those index bits are masked out, and finally invoking a registered handler with the resulting CAN frame"
89,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/hv_shield/hv_shield/hv_shield.c,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}",static int hv_shield_init(const struct device* dev) {,"#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/hv_shield.h>",Initializes a high-voltage shield by configuring its registers and enabling its output,"Initializes a high-voltage shield by configuring its Output Enable (OE) GPIO, writing a zeroed state to its hardware registers, and then setting the OE pin to enable the device's outputs, logging errors at each step"
90,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/hv_shield/hv_shield/hv_shield.c,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {","#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/hv_shield.h>",Sets the gain for a specified DAC on a high-voltage shield,"Sets the gain for a specified DAC (0 or 1) on a high-voltage shield by updating its value in a cached data structure and then calling an update function to write the new configuration to the hardware, returning an error for an invalid DAC index"
91,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/hv_shield/hv_shield/hv_shield.c,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {","#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/hv_shield.h>","Sets a GPIO output enable state, remapping the pin index by swapping the 4-bit nibbles within its byte","Enables or disables a specific GPIO output on a high-voltage shield by validating the pin index (0-31), remapping it via a nibble-swap, modifying a cached register bit, and then calling a helper function to write the update to the hardware"
92,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/can_router/can_router.c,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {","#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/can_router.h>",A callback function that forwards a received CAN frame to another device,"A callback function that forwards a received CAN frame from a source device to a destination device (passed via `user_data`) using a non-blocking send operation, logging a debug message on successful queuing or a warning on failure"
93,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/can_router/can_router.c,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {","#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/can_router.h>",Registers a set of rules to route CAN frames between specified interfaces,"Configures a CAN message router by iterating through an array of routing entries, adding a receive filter to a source CAN interface for each entry that uses a callback to forward matching frames to a destination interface, and returns an error if any filter registration fails"
94,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,lib/can_router/can_router.c,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}",static int can_router_sysinit() {,"#include <zephyr/drivers/can.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <ardep/can_router.h>",Initializes the CAN router by registering all statically-defined routing tables,"Initializes the CAN router by iterating through all statically-defined routing tables found in a dedicated linker section and registering their entries, returning an error if any registration fails"
95,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/hv_shield/gpio/hv_shield_gpio.c,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {","#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/hv_shield.h>",Sets a masked group of GPIO pins to the states defined in a value bitmask,"Iterates through a pre-configured list of low-voltage GPIOs, setting the state of each pin enabled by an input mask to the corresponding bit in a value word, logging and returning an error if any underlying GPIO operation fails"
96,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/lin/abstract_lin/abstract_lin.c,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {","#include <zephyr/device.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>
#include <zephyrboards/drivers/lin.h>",Gets the number of available LIN callback slots,"Populates an output parameter with the number of available Abstract LIN callback slots, calculated by subtracting the used count from a configured maximum, returning an error if the parameter is a null pointer"
97,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/lin/abstract_lin/abstract_lin.c,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {","#include <zephyr/device.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>
#include <zephyrboards/drivers/lin.h>",Registers a callback function for a specific incoming LIN frame,"Registers a user-provided callback function for a specific LIN frame ID by validating the ID (0-0x3F) and data size (1-8 bytes), allocating a free callback slot, and storing the callback details, returning an error on invalid parameters or allocation failure"
98,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/lin/abstract_lin/abstract_lin.c,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {","#include <zephyr/device.h>
#include <zephyr/logging/log.h>

#include <ardep/drivers/abstract_lin.h>
#include <zephyrboards/drivers/lin.h>",Registers a callback function to provide data for a specific outgoing LIN frame,"Registers a user-provided callback function for a specific LIN frame ID by validating the ID (0-0x3F) and data size (1-8 bytes), allocating a free callback slot, and storing the callback details, returning an error on invalid parameters or allocation failure"
99,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/lin/abstract_lin/lin_scheduler.c,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}",int abstract_lin_scheduler_set_active_table(,#include <ardep/drivers/lin_scheduler.h>,Sets the active schedule table for a LIN scheduler and resets its position to the beginning,"Sets the active LIN schedule table by index, first validating the index and then using a semaphore to thread-safely update the scheduler's state and reset its entry pointer to the start of the new table"
100,https://github.com/mercedes-benz/ardep,b971483809c29057020e9b68f05b092937886dbb,drivers/lin/abstract_lin/lin_scheduler.c,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}",void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {,#include <ardep/drivers/lin_scheduler.h>,Stops the LIN scheduler from processing its current schedule table,"Disables a LIN scheduler by first checking if it's already stopped, then taking a semaphore to safely wait for the current operation to complete before setting the active schedule table index to -1"